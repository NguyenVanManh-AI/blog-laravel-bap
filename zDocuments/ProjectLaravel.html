

PBL4 
________________________________________________________________________________________________________
| Database 	        |      Web Server/API	       |    Client – Web Browser                            |
|___________________|______________________________|____________________________________________________|                
| Database          |      API by Laravel          |   Use Nodejs to manage node_modules                |
| Mysql use Xampp   |      have Auth JWT + CRUD    |   Client : Vuejs have Authenticate + RESTful       |
|                   |      OAuth2 Google           |                                                    |
|___________________|______________________________|____________________________________________________|                 
| Data	            |      Get Data in database    |   HTTP/HTTPS Request API                           |
|                   |      Response JSON           |                                                    |
|___________________|______________________________|____________________________________________________|


WEB thường : 
    + Là Web được viết bằng Laravel mà có 3 phần Model , Controller , View 
    + Model để thao tác đọc ghi dữ liệu 
    + Controller để xử lí login 
    + View chứa các framework frontend như Vuejs , React , Angular , Bootstrap , code html,css, js,..
    + Quan trọng là Tất cả MVC đều nằm trong folder Project Laravel chỉ có Data thì tất nhiên được lưu ở Database . 

WEB API :  
    + Web API là web mà trong Laravel chỉ có Model để thao tác với dữ liệu trên database . Controllder để xử lí và viết hỗ trợ viết ra API (JWT + CRUD) dữ liệu 
    + Dữ liệu được API lấy ra từ database chuyển về dạng JSON tương ứng với mỗi URL được gọi đến bằng RESTful thì trả về một Resource nào đó 
        Đó là đọc ra . Còn ghi vào thì chuyển JSON về dạng dữ liệu để lưu vào database . Data JSON do API của Laravel xử lí . 
    + Vì toàn bộ dữ liệu đã về dạng JSON nên Client có thể là bất cứ gì . Được viết bằng bất cứ ngôn ngữ nào 
        Có thể viết bằng Vuejs dùng Axios để RESTful . Có thể viết bằng Reactjs . Có thể viết bằng Angular ,...
        Hoặc thậm chí có ta hoàn toàn có thể viết ra các ứng dụng mobile 
        (Android , iOS ,...) dùng Swift , Kotlin , Fluter ,... miễn là tất cả đều dùng con API đó . 
    => Đó là lí do mà Web API có thể gọi là dùng chung Data , Database , Server và API còn nhiều Client . 
    + Nhưng toàn bộ dữ liệu điều đọc ra và ghi vào chung một chỗ nên rất ok . 

WEB API , dữ liệu lưu vào file database.json không lưu trên Database 
    + Web dạng này cũng giống như WEB API phía trên có client viết bằng bất cứ framework FrontEnd nào Bằng bất cứ ngôn ngữ ,...
    + API có thể tự viết ra có thể bằng Nodejs , Laravel ,... hoặc không thì dùng Firebase 
    + Dữ liệu được đọc ra và ghi vào file database.json . Không có Database để lưu data.  





Phải giải quyết các công việc sau là khỏe 
ĐỌC Documents => Viết API cơ bản : JWT + CRUD , có những cái cần thông qua Auth mới thực hiện được và
cũng có những cái không cần thông qua => tìm kiếm ?title="Tieu de"&"page..." => để tìm kiếm like trong laravel 
=> sau đó => OAuth2 => Load ra dữ liệu từ nhiều bảng 

Vuejs axios : GET mà có thêm các param , ?title="abc"&number="122" => ... sau đó like trong mysql bằng laravel 
=> giải quyết được mấy cái này là khỏe 
+ query nhưng theo cách của laravel : Laravel Eloquent . Tạo mối liên hệ giữa các bảng 1-1 , n-n , 1-n
+ JOIN 2 bảng : https://www.tutsmake.com/laravel-8-joins-example-tutorial/ 
+ like các kiểu => 
    + tham khảo https://www.laravelcode.com/post/laravel-8-where-like-query-example-tutorial
    + thuộc về phần Eloquent model trong file Laravel.html 





Còn lại để Vuejs lo 



Lên ý tưởng đề tài ứng dụng => Thiết kế dabase => viết api 
(kinh nghiệm cho thấy cái database không ổn thì không cái nào ổn cả)(rất dễ đập đi xây lại)

+ Làm cái Auth 
    + đăng nhập 
    + quên password => gửi email 
    + oauth2 luôn 
    => xong 3 cái này rồi làm tiếp (đã làm là làm cho tới)(còn lâu mới thông đồ án)

+ Một số việc cần làm :  
    + Lưu ảnh vào folder trong project Vuejs 
    + Lưu src ảnh vào database vởi Laravel 

    + Quên mật khẩu bằng email 
    + Được thì làm thêm OAuth2 gg_id và fb_id 

    + In file pdf 
    + Thống kê bằng chartjs 
    + onClick , onChange in Vuejs => axios RESTful => API => like data  

    + Response 

    + Nếu có làm cái chọn nhiều ảnh => input => type=file sau đó tìm cách chọn nhiều file cùng lúc 
    + Chú ý file package.json và composer.json của các project => xem để tải những package đó về 

+ Tham khảo : 
    + https://toidicafe.vn/


+ Lưu ý : Ngay cả khi 2 password giống nhau thì mã được hash ra cũng không giống nhau . 


+ Ngoài : 
    + Viết bằng jsp của java => cổng 8080 trùng với cổng của laravel 





zDocument/Laravel.html 
    + Thích thì ctrl + f để tìm lại mà đọc 
    + Nhưng chủ yếu các phần quan trọng mình sẽ lấy ra đây 


    + 
        Biến $Request chứa toàn bộ thông tin của một request (kể cả session,cookie,... tất cả trong lần request đó)
        ex : thêm dòng này vào hàm login : echo $Request->name; , đến http://127.0.0.1:8000/login 
        sửa thành http://127.0.0.1:8000/login?name=Manh => thì nó sẽ hiển thị ra 'Manh' , (ta đã biết biến $_GET sẽ lưu vào [name] => 'Manh' , và ở đây khi ra echo $Request->name; cũng cho 'Manh' => chứng tỏ biến $Request chứa cả biến $_GET)


        => nghĩa là ta các hàm trong Controllder ta không cần khai báo nhiều biến . Ví dụ : 
        ArticleController.php : 
            public function show(Article $article)
            {
                return $article;
            }

            ví dụ bên Vuejs ta gửi HTTP/HTTPS request lên : 
                Axios Vuejs => GET : http://127.0.0.1:8000/api/articles?title="Anh"&content="Noi dung" 
                => theo như PHP ta sẽ có biến GET với $_GET["title"]="Anh" , $_GET["content"]="Noi dung"

            thì bên Laravel sẽ có : $Request->title; $Request->content;
            => cái này ứng dụng trong việc mình tìm kiếm các kiểu . (Bổ sung cho câu gửi các param lên get để server xử lí)

            Sau đó ta truyền các biến này vào hàm trong Model để thao tác 
                            public function index()

                            {
                                return Article::all();
                            }

                            Như ở đây là không truyền vào gì cả chỉ get toàn bộ dữ liệu ra 
                            ở đây có cái hay là đây chính là câu lệnh thu gọn 
                            => cùng một câu lệnh nhưng GET ..../article thì cho toàn bộ bài viết 
                            nhưng GET .../article/1 thì vẫn ra bài số 1 . 

                    + Cách viết ban đầu của nó là chia ra 2 TH . 
                        + 1 là get cụ thể 
                        + 1 là get tất cả 


                    + show(Article $article) thì Article chính là trong Model (tương tác với dữ liệu)
                        use App\Models\Article; use ngay đầu file để dùng bảng này . 
                        Mỗi Controller là chứa toàn bộ code để đọc và ghi dữ liệu .
                        Model là nơi ghi tên các cột ta lấy dữ liệu ra  

                    + Ví dụ như này là đọc dữ liệu ra nhưng có thêm điều kiện . 
                        ví dụ như này id thì mình truyền chữ "you" vào GET để tìm . 
                        GET ..../articles?title="you" => lấy giá trị trong PHP thì $_GET['title'] 
                        còn Laravel thì $request->title sau đó truyền vào model để thực hiện câu sql như thế 
                        sau đó kết thúc bằng ->get(); để lấy ra

                          + where nhiều điều kiện 
                        + where()->where()->where->....->get()
                            + ex : $article10s = Article::where('views_count','>=',100)->where('title','like','%you%')->get();
                            views_count >=100 và title có chữ "you" 


                        + bình thường nếu code web thường thì đó thôi 
                        + còn code web api thì phải trả về json 
                        => 
                            public function store(Request $request)
                            {
                                $article = Article::create($request->all()); // ngay từ ban đầu use Model Article nên giờ dùng 

                                return response()->json($article, 201);
                            }
                        
                        // Article::create là gọi đến hàm create trong Model Article để tạo dữ liệu với dữ liệu gửi vào là 
                                $request->all()

                                sau tất cả lưu vào biến $article sau đó return nó ra 

                            sau đó trả về json $article, 201 , 201 là trạng thái 


                + Request : 
                    + Là một biến 
                    + Chứa toàn bộ thông tin của request 
                    + Lấy các giá trị của request có các cách sau: 
                        + $request->[tên_giá_trị]       ex : echo $Request->name;
                        + $request->post('tên_giá_trị') ex : echo $Request->post('name');
                        + $request->get('tên_giá_trị')  ex : echo $Request->post('name');

                => Một hàm có thể nên tối đa 2 biến : Ví dụ 
                    public function update(Request $request, Article $article)
                    Một biến request và một biến Model 

             
    + Search hàm đọc và ghi dữ liệu trong file 
    + Ghi dữ liệu : 
             1--------------------------------------------------<br>';
                // $article1 = new Article;
             //    $article1->title = 'tieu de 1';
             //    $article1->content = 'noi dung 1';
             //    $article1->author = 'tac gia 1';
             //    $article1->views_count =99;
                // $article1->save(); // thực hiện lưu db 
       

    + paginate(số lượng) phân trang (hay) trong 
            + paginate(số lượng) phân trang (hay)
            + ex : $articles2 = Article::paginate(10); // mỗi lần chỉ lấy ra 10 bài viết 
                   foreach ($articles2 as $article) {
                       echo $article->title;
                       echo '<br>';
                   }  
                   và điều đặc biệt là : http://localhost:8000/test?page=2 , khi mà ta nhập thì sẽ link đến danh sách trang đó luôn 
                   + page tự động có trong laravel  
                   http://localhost:8000/test?page=1 => bài 1 đến bài 10 
                   http://localhost:8000/test?page=2 => bài 11 đến bài 20 
                   http://localhost:8000/test?page=3 => bài 21 đến bài 30 
                           ...
                   http://localhost:8000/test?page=30 => bài 291 đến bài 300
                           ... 



            => Kết hợp 2 thằng này lại là được : Article::paginate(10);  và ?page=1
            có 35 bài => có 4 trang => page = 2 lấy ra bài 11 đến 20 , kiểu kiểu thế 

    + xem thêm cái rule và viết luật vào , bắt lỗi gì trả về cái gì (trong file laravel.html có gi)





CHÚ Ý CÁI BẢNG NÀY ĐỂ RESTful cho đúng 

C:\Users\LAPTOP KIM ANH\Downloads\RestApiLaravel\Laravel-8-JWT-API>php artisan route:list
+--------+----------+------------------------+------+-------------------------------------------------+------------+
| Domain | Method   | URI                    | Name | Action                                          | Middleware |
+--------+----------+------------------------+------+-------------------------------------------------+------------+
|        | GET|HEAD | /                      |      | Closure                                         | web        |
|        | GET|HEAD | api/articles           |      | App\Http\Controllers\ArticleController@index    | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | POST     | api/articles           |      | App\Http\Controllers\ArticleController@store    | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | GET|HEAD | api/articles/{article} |      | App\Http\Controllers\ArticleController@show     | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | PUT      | api/articles/{article} |      | App\Http\Controllers\ArticleController@update   | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | DELETE   | api/articles/{article} |      | App\Http\Controllers\ArticleController@delete   | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | POST     | api/auth/login         |      | App\Http\Controllers\AuthController@login       | api        |
|        | POST     | api/auth/logout        |      | App\Http\Controllers\AuthController@logout      | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | POST     | api/auth/refresh       |      | App\Http\Controllers\AuthController@refresh     | api        |
|        |          |                        |      |                                                 | auth:api   |
|        | POST     | api/auth/register      |      | App\Http\Controllers\AuthController@register    | api        |
|        | GET|HEAD | api/auth/user-profile  |      | App\Http\Controllers\AuthController@userProfile | api        |
|        |          |                        |      |                                                 | auth:api   |
+--------+----------+------------------------+------+-------------------------------------------------+------------+




Vue axios : GET : http://127.0.0.1:8000/api/articles?title=4
    => từ bảng ta thấy GET mà /api/articles => gọi hàm index của ArticleController


ArticleController.php

    public function index(Request $request )
    {
        $article = Article::where('title','like','%'.$request->title.'%')->get(); 
        return $article;
    }


    ?title=4 gửi lên giá trị của title = 4 thì là 4 
    $request->title lây giá trị ra 

    Vue axios : GET : http://127.0.0.1:8000/api/articles?search=4
    thì : $request->search lây giá trị ra là 4 
    sau dấu ? không quan trọng , nó chỉ là cái biến gì đó để ta gửi vào GET của request thôi 
    đặt tên gì thì lấy ra cái đó 
    tương tự ta có thể gửi nhiều biến và giá trị rồi đem ra dùng trong câu lệnh query của laravel 


    => Giải quyết được việc search 
    => Giả sử search trong Vuejs khi bấm nút search thì gửi giá trị trong input vào lâu requery thôi 
    ví dụ nhập vào 'huế' 
    => tạo một cái query vào cho Vuejs axios GET cái đó : 
    Vue axios : GET : http://127.0.0.1:8000/api/articles?search=huế => xong rồi lấy biến $request->search ra để dùng 
    * CHÚ Ý : ?search=huế chứ không phải ?search='huế' 
        vì có này '%'.$request->title.'%' , nói chung là chú ý cái đó 
        Với onChange thì tương tự thôi . Nhưng mà làm onChange thì sẽ hay hơn . 
        Vừa nhập vừa bắt sự kiện và cho nó GET liên tục . (Gửi request liên tục mỗi khi ta nhập)


    *QUAN TRỌNG : ĐỌC THAM KHẢO THÔI CHỨ TEST LẠI THÌ THẤY : http://127.0.0.1:8000/api/articles?title=đề 3 VẪN ĐƯỢC 
        MẤY ĐOẠN LẤY HẾT LÀ DO NÓ REQUEST CHƯA TỚI NƠI THÔI => CÓ ĐỘ TRỄ NHẤT ĐỊNH . 
        => NÓ VẪN SẼ LẤY HẾT ta sẽ có : đề 3 là giá trị cho key title 

        + Nếu giá trị truyền vào có dấu cách thì nên làm một số cách sau 
        + kết thúc bằng dấu # (xem lại cấu trúc url là hiểu nếu cần)
            http://127.0.0.1:8000/api/articles?title=đề 3#
        + thêm một biến nào đó (biến này không dùng cx đc nên thêm thoải mái)
            http://127.0.0.1:8000/api/articles?title=đề 2&t=1

        => để nó biết các giá trị được ngăn cách ngang đó 

        LƯU Ý LÀ CŨNG TÙY NHA : ĐÔI LÚC http://127.0.0.1:8000/api/articles?title=đề 3 lại được 
        trả về : 



        => Nên làm cách dưới này cho chắc  
        => Còn không thì ta làm ntn : http://127.0.0.1:8000/api/articles?title='đề 4'
            => có thêm dấu '' => ta phải sử lý nó 
                $article = Article::where('title','like','%'.substr($request->title,1,-1).'%')->get(); 

                sẽ được là $article = Article::where('title','like','%đề 4%')->get(); 

            + substr($string,1,-1) là loại bỏ đi kí tự đầu và cuối 
                => ta sẽ bỏ đi được kí tự ' nằm ở đầu và cuối 

            + Ngoài ra có thể dùng trim nhưng hơi mệt , trim loại bỏ đi những kí tự 
                $article = Article::where('title','like','%'.trim($request->title,"''").'%')->get(); 

                trim($string,"ab") => loại bỏ đi kí tự ab nằm trong chuỗi $string => nhưng khá rắc rối nên mình không dùng 



        + CHỐT LẠI : NẾU CHUỖI CÓ DẤU CÁCH => BỎ VÀO DẤU '' SAU ĐÓ XỬ LÍ ĐỂ XÓA DẤU '' ĐI 
            http://127.0.0.1:8000/api/articles?title='đề 4'
            $article = Article::where('title','like','%'.substr($request->title,1,-1).'%')->get(); 




            + Để thuận tiện thì ta cũng có thể echo hoặc print_r ra xem thoải mái nha : 
                public function index(Request $request )
                // public function index()
                {
                    print_r($request->title);  <=== 
                    $article = Article::where('title','like','%'.substr($request->title,1,-1).'%')->get(); 
                    // $article = Article::where('id', $request->get('id'))->get(); 
                    // $article = Article::where('id', 3)->get(); 
                    return $article;
                    // return Article::all();
                }


                dùng postman : GET : http://127.0.0.1:8000/api/articles?title='đề 2'
                ta được : 

                'đề 2'[
                {
                    "id": 2,
                    "title": "tiêu đề 2",
                    "body": "nội dung 2",
                    "created_at": "2022-09-11T15:04:33.000000Z",
                    "updated_at": "2022-09-11T15:04:33.000000Z"
                }
                ]



            => CHÚ Ý KHÔNG NÊN print_r($request); => biến $request khá nặng nên hơi lâu thôi 

                    print_r($request->title);  // 'đề 2'
                echo ('%'.substr($request->title,1,-1).'%'); // %đề 2%
                ta được 'đề 2'%đề 2% 

                CHÚ Ý LÀ TA KHÔNG : echo '<br>' hay echo '\n' các kiểu được 

            => MÀ NÓI CHUNG LÚC LAG LAG thì cách này cũng không ăn thua . Nhưng vẫn nên dùng cách này . 
            => ''%% => ra như thế này thì resource nào nó cũng lấy 


            để ntn : http://127.0.0.1:8000/api/articles?title=đề 3
            thì nó in ra biến 
            print_r($request->title); đề 3 
                echo ('%'.substr($request->title,1,-1).'%'); %�ề %
                
            ta được đề 3%�ề %




            => http://127.0.0.1:8000/api/articles?title=đề 3
                đề 3%�ề %[
                    {
                        "id": 3,
                        "title": "tiêu đề 3",
                        "body": "nội dung 3",
                        "created_at": "2022-09-11T15:04:42.000000Z",
                        "updated_at": "2022-09-11T15:04:42.000000Z"
                    }
                ]

            => ntn vẫn được 



=======================
OAuth2 với Google : 
+ configure credentials in google api : 
    + https://www.youtube.com/watch?v=xH6hAW3EqLk  | How to create Google OAuth Credentials (Client ID and Secret) 
+ tham khảo : 
    + https://www.youtube.com/watch?v=hgyc3hSpJ9Y | Đăng nhập Socialite Laravel 8 với Google
+ github tham khảo : https://github.com/siddharth018/googleLogin

=> Về tạo project mình cũng làm rồi . project là googleLogin . Sau này cứ vào project này để tạo 
=> Về cấu hình credentials in google api thì mình làm rồi sau này chỉ cần tạo thôi . 
=> Vào đây : https://console.cloud.google.com/apis/credentials?project=soy-vision-362513
    => CRECREDENTIAL 
    => OAuth Client ID 
    => Web application
    => Name : Ví dụ : PBL4 
    => Authorized JavaScript origins : địa chỉ chính : https://localhost:8080 HAY http://127.0.0.1:8000 THÌ NHƯ ĐÃ GIẢI THÍCH 
    => Authorized redirect URIs : http://127.0.0.1:8000/auth/google/callback => là địa chỉ sẽ đi đến nếu ta đăng nhập thành công 


=> Sau khi tạo xong hiện ra file JSON chứa các thông tin => có thể tải về => import vào và dùng các biến trong đó luôn 
hoặc có thể copy ra để điền vào chỗ mình cần . 
        file service.php : 
             'google' => [
                'client_id' => '1079359168744-5c57ii2sljdgihdh7bmdrculb93q4qut.apps.googleusercontent.com',
                'client_secret' => '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',
                'redirect' => 'http://127.0.0.1:8000/auth/google/callback',
            ],

điền vào file này hoặc điền trực tiếp vào file config . Nhưng tùy code của ta code như nào . 


file JSON : 
{
    "web":{
        "client_id":"1079359168744-5c57ii2sljdgihdh7bmdrculb93q4qut.apps.googleusercontent.com",     <====
        "project_id":"soy-vision-362513",
        "auth_uri":"https://accounts.google.com/o/oauth2/auth",
        "token_uri":"https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url":"https://www.googleapis.com/oauth2/v1/certs",                  <====
        "client_secret":"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",                                       <====
        "javascript_origins":["http://127.0.0.1:8000"]
    } 
}


Tại OAuth 2.0 Client IDs ta có thể chỉnh sửa .  




Lúc thêm URi 
https://localhost:8080 Vuejs 
    => mình lấy laravel làm ip => còn client thì là vuejs => mà vuejs chạy trên cổng 8080 (8081,...)
    => chú ý là nên mở cổng 8080 
https://localhost:8000 Laravel  
    => Nếu web thường => cả vuejs và laravel đều nằm trên folder của laravel 

other links : https://console.cloud.google.com/apis/credentials/consent/edit;newAppInternalUser=false?project=soy-vision-362513


======================================================
Đó là phần để tạo ra API OAuth2 của google 



Bây giờ đến phần tạo giao diện và xử lí => Có 2 loại chính 
    + Nếu nằm ngay trên laravel => gọi và xử lí ngay trên đó 
    + Nên tách ra Vuejs riêng , Laravel riêng 
        + Vuejs gọi đến form login bằng google của Laravel sau đó nó sẽ trả về XTML của form đó => access to XMLHttpRequest laravel
            => hơi củ chuối => mệt 

        + Cách chính thống : Singin OAuth2 Vuejs3 
            + https://www.youtube.com/watch?v=hQ5aqvTEqxU
            + https://github.com/simonjsuh/Vue3-Google-Signin-Youtube-Tutorial-source-code

            + => Hiển thị form ra cũng có các tài khoản . Sau đó khi click vào một tài khoản nào đó 
                => Lấy dữ liệu gửi về cho API của Laravel để xử lí . 

            => Form Login by Google là do Vuejs 
            còn thu được số liệu các thứ từ tài khoản đó thì gửi về cho API Laravel 
            => lúc này URi khi tạo trong Google là : https://localhost:8080 (Vuejs)
            còn sau đó đăng nhập thành công thì chuyển đến trang nào đó . 

        + tham khảo thêm 
            + https://www.npmjs.com/package/vue3-google-oauth2 (HAY)
            + https://developers.google.com/identity/gsi/web/guides/get-google-api-clientid 
            + https://github.com/minuteoflaravel/laravel8-how-to-create-oauth-client-with-laravel-passport


        + URi Đăng nhập | Authorized JavaScript origins => quy định những uri nào được phép dùng client id này 
        + Uri đăng nhập xong | Authorized redirect URIs => quy định chuyển đến những trang sau khi đăng nhập xong 



+ Trong Javascript khi in ra một Object => ta có thể copy nguyên object đó được => chuột phải => copy 
Dữ liệu lấy được : 

{
    "Ca": "106115875168590721730",
    "Cc": {
        "token_type": "Bearer",
        "access_token": "ya29.a0AVA9y1vKZcJRSNnIB_ZJIK0D3tTs9o0qtUs5LJzuo04DqqzGAs3FckxMjIWehcgKS-WgOpG2YN3MvvJz6NMoeAP_Xj75j_xdrkmBN_XCGBxkN_r7JNEuC4-jBinJVaT9F_piWR9JtSOWlvBveIX8HPCVrZjjaCgYKATASARESFQE65dr8P38QpHG1ERlyhfmvgcjElw0163",
        "scope": "email profile openid https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile",
        "login_hint": "AJDLj6JUa8yxXrhHdWRHIV0S13cAy83ypuAh8_uPjgRSYYZIArUEwRn1u9HsAtP8q4IOy2oSWCGXDin_qjNaFs37WWPLPn8lZw",
        "expires_in": 3598,
        "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6ImNhYWJmNjkwODE5MTYxNmE5MDhhMTM4OTIyMGE5NzViM2MwZmJjYTEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwiYXpwIjoiNjc2Nzg1NDYxOTg4LWljb2lsMGR0bGxkMmZjcDVrYjIybGxzdDd0OTRtYW5zLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiYXVkIjoiNjc2Nzg1NDYxOTg4LWljb2lsMGR0bGxkMmZjcDVrYjIybGxzdDd0OTRtYW5zLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwic3ViIjoiMTA2MTE1ODc1MTY4NTkwNzIxNzMwIiwiZW1haWwiOiJ0aGFuaHh1YW50dW9pdHJlLnNreTJAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsImF0X2hhc2giOiJoRXJrZTNSSWs1ZGZldW1NR1ZnbW13IiwibmFtZSI6Ik3huqFuaCBOZ3V54buFbiBWxINuIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FJdGJ2bW5YUnR1X3VOM2JxSmY2VG1wQy13S1daa0k3R0lMVEtMNHl4RzZXPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6Ik3huqFuaCIsImZhbWlseV9uYW1lIjoiTmd1eeG7hW4gVsSDbiIsImxvY2FsZSI6InZpIiwiaWF0IjoxNjYzMTgyNTUzLCJleHAiOjE2NjMxODYxNTMsImp0aSI6IjhmNjY0ZTQ4YzNjNTViODE0MTRmNDEzYzYzMTE5MTg1MTRhN2ZmZDcifQ.dYMq1INc-6CLSpPi0zrPBIlhRUpyZqgB9wgbgKVvOh_JBreygelNzkOlqtOEW6kiG36HrL8_RNjrHC_FvAGIVBYRnAIgVWcEZaCrSoEIY62vN3hTeVAHd9tjf59_mUPz5HilZbgiy9ufGhhc6MUBDrKb_kxc7tUhs-lzWvwxniQEAtBz6pli7nKH-jpkFmrrzNyloHI_CZ0V_SLFATpTyir0ovPrH9k1uJg3PX__4tlbRAvIHTSJhEX2ZotYTcxrTIP0Xof3eavq7hGHFc96gfWpZd-69jR3z7vEtqbgGrXJvosVTqaPJAgVthhL3O2JVR3ADzfbINm3418i_A-dqQ",
        "session_state": {
            "extraQueryParams": {
                "authuser": "5"
            }
        },
        "first_issued_at": 1663182551141,
        "expires_at": 1663186149141,
        "idpId": "google"
    },
    "nv": {
        "aY": "106115875168590721730",
        "yf": "Mạnh Nguyễn Văn",
        "sZ": "Mạnh",
        "FX": "Nguyễn Văn",
        "CO": "https://lh3.googleusercontent.com/a/AItbvmnXRtu_uN3bqJf6TmpC-wKWZkI7GILTKL4yxG6W=s96-c",
        "Yv": "thanhxuantuoitre.sky2@gmail.com"
    }
}




HTTP Method Path    Desciption
GET api/auth/redirect/{provider}    redirect to provider - social redirect
GET api/auth/{provider}/callback    callback url - social register/login
POST    api/register    API normal user register via passport
POST    api/login   API normal user login via passport



{provider} là ta điền vào google hoặc facebook 


SOURCE CODE : Singin OAuth2 Google : 
+ main.js : 

    import { createApp } from 'vue'
    import App from './App.vue'

    const app = createApp(App)
    import gAuthPlugin from 'vue3-google-oauth2';
    let gauthClientId = "779842371071-gn56d5d8o7l8blerqn3nb75v3vnhsbqf.apps.googleusercontent.com";

    app.use(gAuthPlugin, {
      clientId: gauthClientId,
      scope: 'email',
      prompt: 'consent',
    })

    app.mount('#app')


+ package.json 
  "dependencies": {
    "core-js": "^3.8.3",
    "vue": "^3.2.13",
    "vue3-google-oauth2": "^1.0.6"
  },

+ Component : 
    <template>
      <div class="hello">
        <h1>{{ msg }}</h1>
        
        <h1>Is Initialized: {{ Vue3GoogleOauth.isInit }}</h1>
        <h1>Is Authorized: {{ Vue3GoogleOauth.isAuthorized }}</h1>
        <h2 v-if='user'>Logged in user: {{ user }}</h2>

        <button @click='handleSignIn' :disabled='!Vue3GoogleOauth.isInit || Vue3GoogleOauth.isAuthorized'>Sign In</button>
        <button @click='handleSignOut' :disabled='!Vue3GoogleOauth.isAuthorized'>Sign Out</button>
      </div>
    </template>

    <script>
    import { inject } from 'vue';

    export default {
      name: 'HelloWorld',
      props: {
        msg: String
      },

      data() {
        return {
          user: '',
        }
      },

      methods: {
        async handleSignIn() {
          try {
            const googleUser = await this.$gAuth.signIn();
            console.log(this.$gAuth);

            if (!googleUser) {
              return null;
            }

            this.user = googleUser.getBasicProfile().getEmail();
            console.log(googleUser);
            console.log(googleUser.getBasicProfile());
          } catch (error) {
            console.log(error);
            return null;
          }
          
        },
        async handleSignOut() {
          try {
            await this.$gAuth.signOut();
            // console.log(this.$gAuth.signOut);

            this.user = '';
          } catch (error) {
            console.log(error);
          }
        }
      },

      setup() {
        const Vue3GoogleOauth = inject('Vue3GoogleOauth');

        return {
          Vue3GoogleOauth,
        };
      }
    }
    </script>

    <!-- Add "scoped" attribute to limit CSS to this component only -->
    <style scoped>
    h3 {
      margin: 40px 0 0;
    }
    ul {
      list-style-type: none;
      padding: 0;
    }
    li {
      display: inline-block;
      margin: 0 10px;
    }
    a {
      color: #42b983;
    }
    </style>





SINGIN GOOGLE BẰNG LIBRARY NPM DO NGƯỜI DÙNG TỰ VIẾT RA 
    https://github.com/guruahn/vue3-google-oauth2-front-sample
    => GG KHÔNG HỖ TRỢ SỬ DỤNG NỮA => CHỈ ĐƯỢC DÙNG CÁI CỦA GOOGLE 
VÀ DO GOOGLE CUNG CẤP : 
    https://codesandbox.io/s/j3vgt


Lý do con api lúc chiều k hoạt động oauth2 
    + những con trc 29/7/2022 sẽ đc cho phép dùng tiếp còn từ ngày này trở đi thì k đc , phải dùng cách khác


https://console.cloud.google.com/apis/credentials/consent?project=soy-vision-362513
=> Vào đây để đổi tên khi nó hiển thị lên form Đăng nhập Google . 



=======================================================================================================


https://toidicode.com/migrations-trong-laravel-17.html
Lệnh    Chức năng
$table->bigIncrements('id');    Tạo cột id khóa chính tự động tăng kiểu bigint
$table->bigInteger('votes');    Tạo cột votes với kiểu bigint
$table->binary('data'); Tạo cột data với kiểu blob
$table->boolean('confirmed');   Tạo cột confirmed với kiểu boolean
$table->char('name', 4);    Tạo cột name với kiểu char tối đa 4 kí tự
$table->date('created_at'); Tạo cột created_atvới kiểu date
$table->dateTime('created_at'); Tạo cột created_atvới kiểu dateTime
$table->dateTimeTz('created_at');    Tạo cột name với kiểu DATETIME (with timezone)
$table->decimal('amount', 5, 2);     Tạo cột name với kiểu DECIMAL
$table->double('column', 15, 8);    Tạo cột name với kiểu DOUBLE
$table->enum('choices', ['foo', 'bar']);    ENUM equivalent for the database.
$table->float('amount', 8, 2);  FLOAT equivalent for the database, 8 digits in total and 2 after the decimal point.
$table->increments('id');   Incrementing ID (primary key) using a "UNSIGNED INTEGER" equivalent.
$table->integer('votes');   INTEGER equivalent for the database.
$table->ipAddress('visitor');   IP address equivalent for the database.
$table->json('options');    JSON equivalent for the database.
$table->jsonb('options');   JSONB equivalent for the database.
$table->longText('description');    LONGTEXT equivalent for the database.
$table->macAddress('device');   MAC address equivalent for the database.
$table->mediumIncrements('id'); Incrementing ID (primary key) using a "UNSIGNED MEDIUM INTEGER" equivalent.
$table->mediumInteger('numbers');   MEDIUMINT equivalent for the database.
$table->mediumText('description');  MEDIUMTEXT equivalent for the database.
$table->morphs('taggable'); Adds unsigned INTEGER taggable_id and STRING taggable_type.
$table->nullableTimestamps();   Same as timestamps().
$table->rememberToken();    Adds remember_token as VARCHAR(100) NULL.
$table->smallIncrements('id');  Incrementing ID (primary key) using a "UNSIGNED SMALL INTEGER" equivalent.
$table->smallInteger('votes');  SMALLINT equivalent for the database.
$table->softDeletes();  Adds nullable deleted_at column for soft deletes.
$table->string('email');    VARCHAR equivalent column.
$table->string('name', 100);    VARCHAR equivalent with a length.
$table->text('description');    TEXT equivalent for the database.
$table->time('sunrise');    TIME equivalent for the database.
$table->timeTz('sunrise');  TIME (with timezone) equivalent for the database.
$table->tinyInteger('numbers'); TINYINT equivalent for the database.
$table->timestamp('added_on');  TIMESTAMP equivalent for the database.
$table->timestampTz('added_on');    TIMESTAMP (with timezone) equivalent for the database.
$table->timestamps();   Adds nullable created_at and updated_at columns.
$table->timestampsTz(); Adds nullable created_at and updated_at (with timezone) columns.
$table->unsignedBigInteger('votes');    Unsigned BIGINT equivalent for the database.
$table->unsignedInteger('votes');   Unsigned INT equivalent for the database.
$table->unsignedMediumInteger('votes'); Unsigned MEDIUMINT equivalent for the database.
$table->unsignedSmallInteger('votes');  Unsigned SMALLINT equivalent for the database.
$table->unsignedTinyInteger('votes');   Unsigned TINYINT equivalent for the database.
$table->uuid('id'); UUID equivalent for the database.



-Các lệnh thực thi migrations:

php artisan migrate  chạy migration
php artisan migrate:resest   resest lại migration
php artisan migrate:refesh   chạy lại migration
php artisan migrate:status   xem trạng thái của migration
php artisan migrate:install  cài đặt migration








- LƯU Ý : 
    + Những dữ liệu được CRUD bằng hệ thống sẽ tự động có thêm ngày tạo và ngày cập nhật 
        (CRUD bằng API hay bằng web thường nó đều được cả)

    + Những dữ liệu được CRUD trực tiếp trong phpmyadmin thì không có ngày tạo và ngày cập nhật 




- Ví dụ cơ bản : 
    Vẫn là con API cũ : 

    Chạy : \Laravel-8-JWT-API>php artisan make:model Product  -m  
        => Tạo cả Model và file migrate (database) tương ứng 
        (Lưu ý nếu đã có tồn tại folder Models rồi thì chỉ cần ntn thôi)
        Còn nếu chưa thì : php artisan make:model Models/Product  -m
        Nếu có rồi mà còn tạo thì sẽ thành là : Models/Models/Product 


    Chạy : \Laravel-8-JWT-API>php artisan make:controller ProductController --resource
        => tạo file constroller có nhiều phương thức 



    Code vào : 
    2022_09_15_155409_create_products_table.php 

        public function up()
        {
            Schema::create('products', function (Blueprint $table) {
                $table->id();
                $table->text("name");
                $table->longtext("description");
                $table->integer("quality");
                $table->boolean("status");
                $table->timestamps();
            });
        }

    Chạy : \Laravel-8-JWT-API>php artisan migrate



    Model : 
    class Product extends Model
    {
        use HasFactory;
        protected $fillable = ['id', 'name','description','quality','status'];

    }
    => những cột mà ta muốn thao tác dữ liệu 



    Controller : 
    use App\Models\Product; => use Model Product vào để còn tạo biến và gọi dữ liệu
        + Code vào các hàm : 
            + Nếu là web thường thì khi đến request tương ứng đã ghi trong file web.php thì gọi hàm đó 
            + Nếu là api thì khi RESTful đến api_url nào thì sẽ chạy hàm tương ứng đã ghi trong file api.php 

        +   
            class ProductController extends Controller
            {
                // public function __construct()
                // {
                //     $this->middleware('auth:api');
                // }
                // Chỉ cần thêm đoạn này là phải Auth 


                // Còn không thì có cách cụ thể như thế này : 
                // Route::middleware('auth:api')->get('/user', function (Request $request) {
                //     return $request->user();
                // });

                // public function index(Request $request )
                public function index()
                {
                    return Product::all();
                }

                public function show(Product $product )
                {
                    return $product;
                }

                public function store(Request $request)
                {
                    $product = Product::create($request->all());

                    return response()->json($product, 201);
                }

                public function update(Request $request, Product $product)
                {
                    $product->update($request->all());

                    return response()->json($product, 200);
                }

                public function delete(Product $product)
                {
                    $product->delete();

                    return response()->json(null, 204);
                }
            }

        + 
            Nếu muốn cho toàn bộ các phương thức liên quan đến Controllder đó đều có Auth:api 
            thì như đã nói thêm vào hàm _constructor đoạn code đó . 

        + Còn nếu muốn thêm tùy từng cái thì ghi cụ thể tại file api.php 

            + 
                Route::get('products', 'App\Http\Controllers\ProductController@index');
                Route::get('products/{product}', 'App\Http\Controllers\ProductController@show');
                Route::middleware('auth:api')->post('products', 'App\Http\Controllers\ProductController@store');
                Route::middleware('auth:api')->put('products/{product}', 'App\Http\Controllers\ProductController@update');
                Route::middleware('auth:api')->delete('products/{product}', 'App\Http\Controllers\ProductController@delete');

                Ví dụ như này => Những cái có middleware thì cần phải auth:api đã mới được . 

                Đọc thêm chi tiết tại phần : Middleware của Laravel.html (hàng rào)


        + Cách khác nữa là cũng ghi vào __construct nhưng ngoại trừ các hàm đó ra . 

                ta có trong controllers . 
                public function __construct() {
                    $this->middleware('auth:api', ['except' => ['login', 'register']]);
                }

                + except là ngoại trừ => login và register sẽ được ngoại trừ không cần đăng nhập 
                cũng được thực hiện các hàm đó . 

                ta có trong api.php :  
                    Route::group([
                        'middleware' => 'api',
                        'prefix' => 'auth'

                    ], function ($router) {
                        Route::post('login', 'App\Http\Controllers\AuthController@login');
                        Route::post('register', 'App\Http\Controllers\AuthController@register');
                        Route::post('logout', 'App\Http\Controllers\AuthController@logout');
                        Route::post('refresh', 'App\Http\Controllers\AuthController@refresh');
                        Route::get('user-profile', 'App\Http\Controllers\AuthController@userProfile');
                    });




        + file api.php 
            Route::get('products', 'App\Http\Controllers\ProductController@index');
            Route::get('products/{product}', 'App\Http\Controllers\ProductController@show');
            Route::post('products', 'App\Http\Controllers\ProductController@store');
            Route::put('products/{product}', 'App\Http\Controllers\ProductController@update');
            Route::delete('products/{product}', 'App\Http\Controllers\ProductController@delete');

        + 
            // Những cái request nằm trong api.php là tự động thêm /api 
            // Còn những cái Route nằm trong file web.php thì chỉ có / 
            // Đó là quy định rồi . 




        + Vuejs : RESTful : GET : http://127.0.0.1:8000/api/products/2
            => Route::get('products/{product}', => gọi đến 'App\Http\Controllers\ProductController@show');
            => hàm show trong controllser Product : 
                public function show(Product $product ) 
                {
                    return $product;
                }

            => gọi đến Model Products => để lấy dữ liệu lên . 
                return  $products là cách viết rút gọn . Đúng ra là phải chỉ rõ id là bao nhiêu đó là cách viết chi tiết . 


    => Như vậy là đủ các theo tác CRUD dữ liệu bằng API một cách Basic . 

    => Đối với get và get/id Ta có thể dùng Postman hoặc mở trực tiếp ngoài browser :
            http://127.0.0.1:8000/api/products/2
            Sau khi cài tiện tích JSON master thì nhìn khá là đẹp . 




=> Việc tiếp theo là học kỹ phần 
    + API Auth bằng JWT .
        + ngoài các thông tin cơ bản thì table users còn thêm nhiều thông tin khác (adress,number_phone,...) 
    + middleware (luật phải làm gì đó đã mới được vào)(ví dụ phải đăng nhập đã mới vào được)
    + OAuth2 . Gửi token và id_google từ Vuejs đến API Laravel để xử lí 
        + Cái này đọc trong file Laravel.html và xem lại video của anh Nguyện để xem cách xử lí 
        + Xem tham khảo code và video trên Youtube để xem cách xử lí . 

    + Quên mật khẩu bằng Email . 

    + Hoàn thành phần API này cho chuẩn đã rồi tính tiếp . 
        + Auth 
            + JWT 
            + Forgot Password by Veri Email 
            + OAuth2 Google 

        + CRUD Article cần đăng nhập 
        + CRUD Product không cần đăng nhập 
        => 2 cái này mô phỏng thôi . Chứ chỉ cần thêm đoạn code middleware như đã nói trong Controllder là xong 



=> Tiếp 
    + Đọc tiếp tài liệu của Laravel 
    + Thiết kế Database có các mối quan hệ (1-1,1-n,n-n)
    + Viết các hàm xử lí trong Controllser . 

    + Viết Client bằng Vuejs 


+ Forgot Password by Veri Email 
    + Vuejs gửi yêu cầu về API => API gửi mail (xử lí trong controller các kiểu) => nhận code => gửi về lại cho Vuejs








+ add_[tên cột]_to_[tên bảng]_table : Thêm một cột vào bảng 
    + Giả sử project ta đã hoàn thành , đã chạy php artisan migrate, đã có hết dữ liệu,... đầy đủ hết .
    => bây giờ update lên version mới , update nhiều cái mới , ex : trong bảng articles cần thêm cột author 
    
    + B1 :  đến project đó : ex project3 
        C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan make:migration add_author_to_articles_table 
        => Created Migration: 2021_09_08_160158_add_author_to_articles_table
        (Tạo ra một file 2021_09_08_160158_add_author_to_articles_table.php trong migrations, máy sẽ hiểu là đã có bảng articles bây giờ chỉ cần thêm cột author là được)
        Ở file mà ta tạo bình thường sẽ là : Schema::create
        Còn file thêm cột sẽ là : Schema::table
    
    + B2 : vào file đó => 
        trong hàm up() :    Schema::table('articles', function (Blueprint $table) {
                                $table->string('author');
                            });

        trong hàm down() :  Schema::table('articles', function (Blueprint $table) {
                               $table->dropColumn('author');
                            });
    + B3 : C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan migrate 
    => chính thức thêm cột đó vào bảng ở database 
+ Cột được thêm vào sẽ nằm cuối cùng (dùng ->after())
    => Để thêm cột vào vị trí ta muốn thì làm như sau :
    giả sử thêm cột votes vào sau cột content 
    C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan make:migration add_votes_to_articles_table 
        trong hàm up() :    Schema::table('articles', function (Blueprint $table) {
                                    $table->string('votes')->after('content');
                                });
        trong hàm down() :  Schema::table('articles', function (Blueprint $table) {
                                   $table->dropColumn('votes');
                                });                        
    C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan migrate 
    => cột votes thêm vào sau cột content 





RULE : 

    + 'phone_number' => 'required|min:9|numeric',
        => chỉ được chứa kí tự số . ít nhất 9 kí tự . 


    + php artisan make:rule [tên_file]

    + 'age' => 'required|date|before_or_equal:'.\Carbon\Carbon::now()->subYears(18)->format('Y-m-d')
        => Kiểm tra trực tiếp từ ngày thàng 
        + POST JSON : "age":"2022-1-1" : => 
            "age": [
                "The age must be a date before or equal to 2004-09-16."
            ]
            => đến ngày hiện tại vẫn chưa đủ 18 tuổi . Ít nhất phải từ 2004-09-16 mới đủ . 


        + JSON : "age":"2004-09-16" => sửa lại ngày bé hơn ngày này là được . ví dụ : 2004-09-15 

    + JSON "age":19
        =>     "age": [
                    "The age is not a valid date."
                ]

            => không đúng giá trị đã quy định , không đúng format 

    + JSON : "age":"222004-09-16"

            "age": [
                "The age is not a valid date.",
                "The age must be a date before or equal to 2004-09-16."
            ]

            => vừa không đúng giá trị vừa không đủ 18 tuổi . 


    + Những lỗi này là Laravel tự ghi ra chứ mình chưa ghi gì cả . 


    + gói Carbon là gói để quản lí ngày tháng 
        + tham khảo : https://www.digitalocean.com/community/tutorials/easier-datetime-in-laravel-and-php-with-carbon



    + Cách khác : tương tự : 
        use Carbon\Carbon;         ////++ 

        $dt = new Carbon();        ////++ 
        $before = $dt->subYears(18)->format('Y-m-d');        ////++ 

        $validator = Validator::make($request->all(), [
            'name' => 'required|string|between:2,100',
            'email' => 'required|string|email|max:100|unique:users',
            'password' => 'required|string|confirmed|min:6',
            'adress' => 'required|string|min:1',
            'phone_number' => 'required|min:9|numeric',
            'age' => 'required|date|before:' . $before,        ////++ 
        ]);




    + Trong file controller => trong mỗi hàm register, login các kiểu . cứ ghi luật vào là nó tự có lỗi phát ra . 
        {
            "name": [
                "The name field is required."
            ],
            "email": [
                "The email field is required."
            ],
            "password": [
                "The password field is required."
            ],
            "adress": [
                "The adress field is required."
            ],
            "age": [
                "The age must be a date before 2004-09-16."
            ]
        }


        Các lỗi này được laravel ghi ra dựa trên các luật mà ta đã ghi vào . Nếu không đạt các luật đó thì 
        các lỗi này sẽ bật ra . 



    public function __construct() {
        $this->middleware('auth:api', ['except' => ['login', 'register']]);
    }
    // là hàm chạy đầu tiên . ''







    public function check($name){
        if(strlen($name)<10){
            echo "Tên nhỏ hơn 10 kí tự";
        }
    }

    public function register(Request $request) {
        $dt = new Carbon();
        $before = $dt->subYears(18)->format('Y-m-d'); // tất nhiên trong một hàm có thể khai báo thoải mái . 
        // có thể khai báo hàm ngoài rồi dùng trong hàm này các kiểu . 
        // nói chung là đủ kiểu . 
        AuthController::check($request->name); // không cần khai báo biến => gọi hàm trực tiếp bằng class 
        // nếu name nhỏ hơn 10 kí tự thì nó echo ra cái đó  

        $validator = Validator::make($request->all(), [
            'name' => 'required|string|between:2,100',
            'email' => 'required|string|email|max:100|unique:users',
            'password' => 'required|string|confirmed|min:6',
            'adress' => 'required|string|min:1',
            'phone_number' => 'required|min:9|numeric',
            'age' => 'required|date|before:' . $before,
        ]);

        /// $request->all() lấy ra tất cả request 
        // sau đó lặp qua từng key của nó => rồi thực hiện luật 
        // chỉ cần một cái sai luật => $validator->fails() => return json lỗi và trả về status 400 

        if($validator->fails()){
             return response()->json($validator->errors(), 400); 
        }

        // tất nhiên cứ tới chỗ nào mà nếu câu lệnh return đó được thực hiện thì sẽ kết thúc chương trình . 

        // ngược lại nếu không lỗi thì không thực hiện if đó 
        Thực hiện hàm tạo user . User::create => dùng class để gọi trực tiếp hàm create (hàm tạo) cho Model User  
        $user = User::create(array_merge(
                    $validator->validated(),
                    ['password' => bcrypt($request->password)] // hash password trong laravel 
                ));

        sau đó trả về json bao gồm thông báo thành công , thông tin được lưu vào của user và code 201 

        return response()->json([
            'message' => 'User successfully registered',
            'user' => $user
        ], 201);
    }






    public function login(Request $request){
        // tạo luật 
        $validator = Validator::make($request->all(), [
            'email' => 'required|email',
            'password' => 'required|string|min:6',
        ]);

        // nếu sai luật thì thực hiện trả về json sai luật , và status code 422 
        if ($validator->fails()) {
            return response()->json($validator->errors(), 422);
        }

        // check token 
        // nếu token không hợp lệ => trả về Either email or password is wrong và code 401 
        if (! $token = auth()->attempt($validator->validated())) {
            return response()->json(['error' => 'Either email or password is wrong.'], 401);
        }

        // ngược lại nếu đăng nhập thành công thì trả về token mới 
        return $this->createNewToken($token);
    }


    CHÚ Ý : $token này là tự có , nói chung là cú pháp nó vậy => chỉ cần ghi đúng như thế là được . 









Tốt nhất là nên lấy ra hết và khi ghi luật cho rõ ràng . 
Ghi đúng tên các cột trong migrate => cho đến model và phải giống tên các key được gửi lên . 
Lỗi đầu 5 (ví dụ là 500 là lỗi của server và lỗi do ta code lỗi)
Còn lỗi đầu 4 là do user ví dụ nhập vào số điện thoại mà có cả kí tự => gửi lỗi về . 

Model : 
    protected $fillable = [
        'name',
        'email',
        'password',
        'address',
        'age',
        'phone_number',
        'role'
    ];


Controllder 
    public function register(Request $request) {
        $validator = Validator::make($request->all(), [
            'name' => 'required|string|between:2,100',
            'email' => 'required|string|email|max:100|unique:users',
            'password' => 'required|string|confirmed|min:6',
            'address' => 'required|string|min:1',
            'phone_number' => 'required|min:9|numeric',
            'age' => 'required',
            "role" => "required"
        ]);



{
            "email": "nguyenvanmanh2001it1@gmail.com",
        "password": "vanmanh123",
        "name":"Nguyen Van Manh",
        "password_confirmation":"vanmanh123",
        "address":"Hue Viet Nam",
        "phone_number":"0971404372",
        "age":"21",
        "role":"admin"
}



{
    "message": "User successfully registered",
    "user": {
        "name": "Nguyen Van Manh",
        "email": "nguyenvanmanh2001it1@gmail.com",
        "address": "Hue Viet Nam",
        "phone_number": "0971404372",
        "age": "21",
        "role": "admin",
        "updated_at": "2022-09-16T12:43:08.000000Z",
        "created_at": "2022-09-16T12:43:08.000000Z",
        "id": 1
    }
}




Kinh nghiệm rút ra từ PBL trước là không nên bắt lỗi quá chi tiết => Nên tập trung vào viết code xử lý login và hệ thống 
    => Cứ ghi luật là xong còn lỗi thì do laravel tự xuất ra . 







+ Mở đầu cho phần gửi mail . 
    + Ví dụ cho việc gửi giá trị và xử lí api một cách basic . 

    + Ta có thể gửi đến một api bất kì . Miễn là ứng với api đó có hàm của controllder xử lí nó . 

        Giả sử ta có phương thức GET cái gì đó , đồng thời có gửi lên giá trị gì đó để xử lí . 
        Route::get('test1', 'App\Http\Controllers\ProductController@test1');
        Route::middleware('auth:api')->get('test2', 'App\Http\Controllers\ProductController@test2');

        => Ví dụ nếu đến : http://127.0.0.1:8000/api/test1 thì gọi hàm test1 trong ProductController
            đến http://127.0.0.1:8000/api/test2 thì phải cần đăng nhập sau đó mới được gọi hàm test2 trong ProductController


    + trong ProductController ta code 2 hàm tương ứng : 
        public function test1(Request $request)
        {
            if($request->n > 10){
                return response()->json([
                    "message"=>"Test1 Giá trị bạn gửi lên là : ".$request->n." lớn hơn 10",
                ], 200);
            }
            else {
                return response()->json([
                    "message"=>"Test1 Giá trị bạn gửi lên là : ".$request->n." không lớn hơn 10",
                ], 400);
            }

        }
        public function test2(Request $request)
        {
            return response()->json([
                "message"=>"Test2 Giá trị bạn gửi lên là : ".$request,
            ], 200);
        }

        code được trả về tùy vào ta muốn cho status code bao nhiêu thì cho . 
            Nhưng cũng phải phù hợp với quy tắc trả về status .



    + Ứng dụng trong việc gửi mail .  
        + Ta sẽ gửi lên mail của người dùng hoặc id của người dùng hoặc username của người dùng bằng phương thức get 
        và cho controllder xử lí với cái mail đó => gửi code đến gmail => ta vào xem và nhận lại code 
        => nhập code => veri password => change password . 

        + đầu vào là email => đầu ra là code được gửi đến email . 


    + Code Demo : 
        Route::group([
            'middleware' => 'api',
            'prefix' => 'auth'

        ], function ($router) {
            Route::post('login', 'App\Http\Controllers\AuthController@login');
            Route::post('register', 'App\Http\Controllers\AuthController@register');
            Route::post('logout', 'App\Http\Controllers\AuthController@logout');
            Route::post('refresh', 'App\Http\Controllers\AuthController@refresh');
            Route::get('user-profile', 'App\Http\Controllers\AuthController@userProfile');
            Route::get('forgot-password', 'App\Http\Controllers\AuthController@forgotpassword');   ////+ 
        });



        GET : http://127.0.0.1:8000/api/auth/forgot-password => gọi đến hàm forgotpassword trong AuthController

        => Vì do 
        Route::group([
            'middleware' => 'api',
            'prefix' => 'auth'
        ],

        nghĩa là các route này yêu cầu cần phải đăng nhập mới thực hiện được 

        => vào AuthController ngoại trừ đi : 
            public function __construct() {
                $this->middleware('auth:api', ['except' => ['login', 'register','forgotpassword']]);
            }

            những hàm này không cần đăng nhập cũng thực hiện được . 


        code hàm forgotpassword
            public function forgotpassword(Request $request) {
                // code xử lí gửi Mail . 
                return response()->json([
                    "code"=>rand(100000, 999999),
                    "message"=>"EMail của bạn gửi lên là :".$request->email
                ],200);
            }



        => Kết quả : GET : http://127.0.0.1:8000/api/auth/forgot-password
            JSON : 
                {
                    "email":"nguyenvanmanhpro@gmail.com"
                }


            Nhận lại : 
                Status : 200 

                {
                    "code": 818267,
                    "message": "EMail của bạn gửi lên là :nguyenvanmanhpro@gmail.com"
                }






    + Thêm biến vào return view('tên_file','biến')
        public function show(Request $Request){
            $name = 'Nguyen Van Manh';
            $age = 20;
            return view('article',['ten' => $name,'tuoi' => $age]);
        }





+ từ username => lấy ra email của username đó => gửi code => xác thực => đổi password 
    (password cũng sẽ được gửi vào trong email luôn) . 
    hoặc có thể là do người dùng nhập . 
        => ta cũng viết luật cho password được gửi vào .   





============================== Gửi mail . ==============================
    
- Code gửi mail : 
    + https://www.tutsmake.com/laravel-8-send-email-example/

    B1 : Điền thông tin vào file cấu hình .env 
    + .env 
        MAIL_MAILER=smtp
        MAIL_HOST=smtp.gmail.com
        MAIL_PORT=587 
        MAIL_USERNAME=strongtechmaster@gmail.com
        MAIL_PASSWORD=mylbiboicxumjzzn                       
        MAIL_ENCRYPTION=tls 
        MAIL_FROM_ADDRESS=strongtechmaster@gmail.com
        MAIL_FROM_NAME="${APP_NAME}"


        + MAIL_PASSWORD=mylbiboicxumjzzn  , mylbiboicxumjzzn không phải là password của tài khoản này mà nó là mật khẩu ứng dụng 
            => sẽ được nói sau 


    B2 : tạo file views/emails/demoMail.blade.php 
        <!DOCTYPE html>
        <html>
        <head>
         <title>Laravel 8 Send Email Example</title>
        </head>
        <body>
         
         <h1>This is test mail from Tutsmake.com</h1>
         <p>Laravel 8 send email example</p>
         
        </body>
        </html> 

    B3 : Tạo file mail  
    + >php artisan make:mail NotifyMail
        code vào : 
            <?php
             
            namespace App\Mail;
             
            use Illuminate\Bus\Queueable;
            use Illuminate\Contracts\Queue\ShouldQueue;
            use Illuminate\Mail\Mailable;
            use Illuminate\Queue\SerializesModels;
             
            class NotifyMail extends Mailable
            {
                use Queueable, SerializesModels;
             
                public function __construct()
                {
                    //
                }
             
                public function build()
                {
                    return $this->view('emails.demoMail'); //// trả về file /views/emails/demoMail.blade.php 
                }
            }

    B4 : Tạo router khi đi đến : http://127.0.0.1:8000/send-email => gọi hàm index của SendEmailController
    + web.php 
        use App\Http\Controllers\SendEmailController;
        Route::get('send-email', [SendEmailController::class, 'index']);


    B5 : code gửi Mail 
    + >php artisan make:controller SendEmailController
        code vào : 
        <?php
         
        namespace App\Http\Controllers;
         
        use Illuminate\Http\Request;
         
        use Mail;
         
        use App\Mail\NotifyMail;
         
        class SendEmailController extends Controller
        {
             
            public function index()
            {
         
                Mail::to('nguyenvanmanh2001it1@gmail.com')->send(new NotifyMail());       ////(1)

                if (Mail::failures()) {
                    return response()->Fail('Sorry! Please try again latter');
                }
                else{
                    return response()->success('Great! Successfully send in your mail');
                }
            } 
        }


    > php artisan serve 
    > đi đến : http://127.0.0.1:8000/send-email


    Giải thích :
        + B4 : Khi đi đên http://127.0.0.1:8000/send-email => gọi hàm index của SendEmailController
        + B5 : thực hiện hàm index() . 
            (1) : Gửi đến nguyenvanmanh2001it1@gmail.com với nội dung là (new NotifyMail())
            + nếu thành công trả về "Great! Successfully send in your mail"
            + nếu thất bại trả về : "Sorry! Please try again latter"

        + new NotifyMail() => B3 : return $this->view('emails.demoMail'); => trả về nội dung file 
            /views/emails/demoMail.blade.php của B2 


    => XONG . 

    + NÓI THÊM : 
        + Toàn bộ nội dung trong file /views/emails/demoMail.blade.php sẽ được gửi đến gmail : nguyenvanmanh2001it1@gmail.com
            bằng gmail strongtechmaster@gmail.com 
        + ƯU ĐIỂM : Ta có thể tùy biến nội dung được gửi đến . Không chỉ là văn bản thuần mà là một file html hoàn chỉnh . 
            (có thể có cả ảnh , link , video,...) Nói chung là bất cứ thứ gì . 

        + Đó là đối với web thuần => đi đến router : http://127.0.0.1:8000/send-email => sẽ gọi hàm đó
        + Ta phải code lại cho API để thực hiện RESTful API thì phải thực hiện hàm gửi Mail .

        + Nói về : MAIL_PASSWORD=mylbiboicxumjzzn
            + Nó là mật khẩu ứng dụng chứ không phải là mật khẩu của gmail strongtechmaster@gmail.com 
            + Như đã biết sau ngày 30 tháng 5 năm 2022 thì Google không cho phép bên thứ 3 dùng tài khoản google 
                để gửi mail nữa : https://support.google.com/accounts/answer/6010255

            + Để dùng tài khoản gmail để gửi mail phải dùng cách khác : 
                + tham khảo : 
                    + https://www.cambotutorial.com/article/solved-gmail-smtp-less-secure-app-no-longer-support
                    + https://www.youtube.com/watch?v=L5LAqIABGZE

            + Thay vì dùng mật khẩu ta phải tạo ra mật khẩu cho ứng dụng đó từ gmail rồi dùng thay mật khẩu . 
            + Các bước tiến hành : 
                + Vào Tài khoản google mà mình dùng cho project (gmail : strongtechmaster@gmail.com)
                + Chọn Bảo mật : https://myaccount.google.com/security?hl=vi
                + Tại phần : Đăng nhập vào Google có 2 phần đó là 
                    + Xác minh 2 bước 
                    + Mật khẩu ứng dụng 

                    => Nếu chưa bật xác minh 2 bước => thì đi bật xác minh 2 bước lên 
                    => Đến bước chính là : Mật khẩu ứng dụng 

                + Click vào Mật khẩu ứng dụng 
                + Tại phần : Chọn ứng dụng và thiết bị bạn muốn tạo mật khẩu ứng dụng.
                    + Tại phần : Chọn ứng dụng => Select chọn "Thư" (chọn đại cũng được ấy mà , nhưng chọn Thư sẽ hợp lí hơn)
                    + Tại phần : Chọn thiết bị => Select chọn "Máy tính dùng Window"

                + Click nút TẠO 
                => Hiện ta Bảng chứa code là mật khẩu ứng dụng : LÀ DÒNG MÀU VÀNG 
                    => mylbiboicxumjzzn => đây sẽ là cái mình cần 

                => XONG . Đem cái này điền vào MAIL_PASSWORD trong file .env 


            + Lưu ý là ta có thể tạo ra nhiều cái mật khẩu ứng chụng cho nhiều project của ta chỉ với 1 gmail đó . 



- Code lại cho API : 
    + RESTful API thì thực hiện hàm gửi Mail 
    + Ngoài đoạn html được gửi đi đó phải có thêm MÃ CODE nữa . 
    + Phần quên mật khẩu gồm 2 phần : 
        + send code 
            + người dùng nhập vào username hoặc email 
                + mình sẽ dùng username được gửi lên và tìm trong database ra email ứng với username đó
                + hoặc dùng trực tiếp email được gửi lên
                + random ra một số gồm 6 chữ số => lưu số đó lại để còn so sánh .  

            + gửi code đến email đó => thông báo thành công hoặc thất bại => người dùng vào xem mail => nhận code  

        + verycode  
            + người dùng gửi mã code lên => nhận mã code => so sánh với mã code mình gửi vào mail 
            => nếu trùng => cho người dùng nhập vào mật khẩu => thay đổi 
            => nếu không trùng => thông báo sai mã . 


    + sendcode :  
        + .env : giữ nguyên 
        + api.php : 

            ], function ($router) {
                Route::post('login', 'App\Http\Controllers\AuthController@login');
                Route::post('register', 'App\Http\Controllers\AuthController@register');
                Route::post('logout', 'App\Http\Controllers\AuthController@logout');
                Route::post('refresh', 'App\Http\Controllers\AuthController@refresh');
                Route::get('user-profile', 'App\Http\Controllers\AuthController@userProfile');
                Route::get('forgot-password/sendcode', 'App\Http\Controllers\AuthController@sendcode');   ////+++ 
            });


        + AuthController@sendcode 

            public function __construct() {
                $this->middleware('auth:api', ['except' => ['login', 'register','sendcode']]);
            }

                => hàm sendcode cũng không cần auth:api  

            ...


            public function sendcode(Request $request) {

                $code = rand(100000, 999999);
                Mail::to($request->email)->send(new NotifyMail($code));  /// khởi tạo NotifyMail và truyền $code vào 
         
                if (Mail::failures()) return response()->json(["message"=>"Sorry! Please try again latter"],400);
                else return response()->json(["message"=>"Great! Successfully send in your mail"],200);
            } 

            /// $request->email nhận email từ client gửi lên . 

        + NotifyMail
            <?php
             
            namespace App\Mail;
             
            use Illuminate\Bus\Queueable;
            use Illuminate\Contracts\Queue\ShouldQueue;
            use Illuminate\Mail\Mailable;
            use Illuminate\Queue\SerializesModels;
             
            class NotifyMail extends Mailable
            {
                use Queueable, SerializesModels;
             
                public $code; // khai báo biến của class để còn dùng cho hàm build()
                public function __construct($_code) /// hàm khởi tạo nhận biến được truyền vào 
                {
                    $this->code = $_code; // gán giá trị cho biến của class 
                }
             
                public function build()
                {
                    return $this->view('emails.demoMail',['__code' => $this->code]); //(1)
                }
            }

            (1) : trả về nội dung file views/emails/demoMail.plade.php đồng thời truyền giá trị vào . 


        + views/emails/demoMail.plade.php
            <!DOCTYPE html>
            <html>
            <head>
                <title>Laravel 8 Send Email Example</title>
            </head>
            <body>

                <h1>This is test mail from PBL4</h1>
                <p>Laravel 8 send email example | Nguyen Van Manh</p>
                <h1 style="color: red;">{{$__code}}</h1>

            </body>
            </html> 


            => Đây là nội dung được gửi đi . 


        + Postman : GET : http://127.0.0.1:8000/api/auth/forgot-password/sendcode
            {
                "email":"buongtaynhenhang99@gmail.com"
            }

            Nhận lại : 
            {
                "message": "Great! Successfully send in your mail"
            }

            => Vào kiểm tra mail => Có mail được gửi đến 
                (Nếu không thấy thì nằm trong hộp thư rác => xác nhận là không phải thư spam là nó chuyển ra hộp thư chính)


    + verycode :  
        ....


+ https://www.positronx.io/laravel-jwt-authentication-tutorial-user-login-signup-api/

+ Cách để xem code theo những cái có trên github một cách dễ dàng đó là 
    + Vào xem các folder 
    + Nhưng file được cài ngay từ đầu cùng lúc với project thì commnent của nó khác nhau hết 
    + Những file có commnent khác và thời gian khác => là những file được chỉnh sửa 
    => chỉnh sửa giống các file đó là được . 

    + bài gốc : https://github.com/camposgaston/Laravel-8-JWT-API (GỐC)
    + config 
        + app.php 
        + jwt.php (tạo file)
        + auth.php 


    + .env => thêm : JWT_SECRET= (biến global)
    + logout() cũng cần token (nghĩa là phải đăng nhập vào đã => midware authen)
    + Đúng ra chỉ lưu token hoặc cookie thôi . Cơ mà để cho khỏe thì lưu luôn biến user luôn cũng được 
        + Mỗi lần làm cái gì đó thì gửi cookie lên để where(cookie như thế => lấy giá trị trong table user ...)
        sau đó rồi làm các thao tác tiếp . Có thể thay cookie bằng token . 

    + Nhưng vẫn có những trang web pro họ cũng lưu cả biến user thôi . 
        + Thật ra lưu token hoặc cookie sẽ ok hơn 
        Vì mỗi lần là mỗi cái riêng biệt => lưu vào database cho mình luôn 
        + Còn user thì nó hiện ra hết toàn bộ thông tin của người dùng luôn nhưng đổi lại được cái khỏe cho mình 
            => cứ có sẵn thông tin đó => đem ra dùng . 
    + PUT
        Theo HTTP RFC, khi sử dụng PUT để update, ta phải gửi 1 bản ghi đầy đủ các field để yêu cầu cập nhật. Nếu chỉ gửi 1 số field nhất định thì những field còn lại sẽ bị xóa (tức bị null)


    + PTACH : 
        + Theo HTTP RFC, PATCH giống PUT về ý nghĩa nhưng khác nhau về cách làm việc, nó chỉ thay đổi những field được yêu cầu thay vì thay đổi toàn bộ record.



+ Resting Password in Laravel 8 
    + Đó là code chay , tự code toàn bộ từ a-z 
    + Dưới đây là cách sử dụng những cái có sẵn trong Laravel . Đổi mật khẩu bằng cách gửi link . 
    + Ngon hơn nhiều so với việc mình tự đi code chay . Nhìn xịn hơn nữa . 

    + https://viblo.asia/p/reset-password-voi-laravel-passport-authentication-api-rest-V3m5Wbr7lO7
        public function sendMail(Request $request,User $user)
        => đúng ra không cần thêm mà cũng cần phải thêm User $user



+   if($request->hasFile('picture')){ 
    + tham khảo : https://stackoverflow.com/questions/60198779/how-to-update-user-through-api-in-laravel





+ user còn thiếu giới tính . Gender 
    in | male , female 



+ Delete  
    https://viblo.asia/p/delete-va-destroy-trong-laravel-co-the-ban-chua-biet-924lJbaNlPM


+ LƯU Ý => KHI CẬP NHẬP THÊM CỘT => THÌ PHẢI CẬP NHẬP THÊM TRƯỜNG DỮ LIỆU TRONG MODEL 

+ add_[tên cột]_to_[tên bảng]_table : Thêm một cột vào bảng 
    + Giả sử project ta đã hoàn thành , đã chạy php artisan migrate, đã có hết dữ liệu,... đầy đủ hết .
    => bây giờ update lên version mới , update nhiều cái mới , ex : trong bảng articles cần thêm cột author 
    
    + B1 :  đến project đó : ex project3 
        C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan make:migration add_author_to_articles_table 
        => Created Migration: 2021_09_08_160158_add_author_to_articles_table
        (Tạo ra một file 2021_09_08_160158_add_author_to_articles_table.php trong migrations, máy sẽ hiểu là đã có bảng articles bây giờ chỉ cần thêm cột author là được)
        Ở file mà ta tạo bình thường sẽ là : Schema::create
        Còn file thêm cột sẽ là : Schema::table
    
    + B2 : vào file đó => 
        trong hàm up() :    Schema::table('articles', function (Blueprint $table) {
                                $table->string('author');
                            });

        trong hàm down() :  Schema::table('articles', function (Blueprint $table) {
                               $table->dropColumn('author');
                            });
    + B3 : C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan migrate 
    => chính thức thêm cột đó vào bảng ở database 
+ Cột được thêm vào sẽ nằm cuối cùng (dùng ->after())
    => Để thêm cột vào vị trí ta muốn thì làm như sau :
    giả sử thêm cột votes vào sau cột content 
    C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan make:migration add_votes_to_articles_table 
        trong hàm up() :    Schema::table('articles', function (Blueprint $table) {
                                    $table->string('votes')->after('content');
                                });
        trong hàm down() :  Schema::table('articles', function (Blueprint $table) {
                                   $table->dropColumn('votes');
                                });                        
    C:\Users\nguye\OneDrive\Máy tính\Laravel\learnlaravel\laravel3>php artisan migrate 
    => cột votes thêm vào sau cột content 



    'ses' => [
        'key' => env('AWS_ACCESS_KEY_ID'),
        'secret' => env('AWS_SECRET_ACCESS_KEY'),
        'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
    ],


    env() => các tham số được lấy ra từ file env 






token : https://jwt-auth.readthedocs.io/en/develop/auth-guard/




Các TH 
    + Có google_id 
        => đăng nhập luôn 

    + Không có google_id 
        + không có email 
            => đăng kí tài khoản mới 
        + có email 
            => cập nhật thêm google_id 















===================================================================================================================

                                            Mô tả đồ án : Web Bán hàng 


+ User (Giao diện chính)
    + Đăng kí 
    + Đăng nhập 

    + Tài khoản của tôi 
        + Hồ sơ 
        + Đổi mật khẩu 
        + Địa chỉ 
        + Đơn mua 
    + Đơn hàng 
    + Đăng xuất 

    + Tìm kiếm sản phẩm đa tiêu chí 
    + Xem danh mục sản phẩm 
        + Tất cả 
        + ....

    + Sắp xếp theo mới nhất , giá (từ thấp đến cao) (từ cao đến thấp) , tên . 

    + Sau khi bấm tìm kiếm => load ra tìm kiếm thì đồng thời cũng hiện ra bộ lọc giá từ bao nhiêu đó đến bao nhiêu đó 

    + Click vào sản phẩm 
        => Load ra chi tiết sản phẩm 
        + Thêm vào giỏ hàng 
        + Mua ngay 


    + Giỏ hàng 
        + Tất cả các sản phẩm đã được thêm  
        + Tên sản phẩm , giá , có thể thêm hoặc bớt số lượng 
        + Hoặc xóa đi 
        => Mua hàng => Nếu chưa đăng nhập => chuyển đến trang đăng nhập 
        => Đăng nhập thành công thì chuyển về lại trang Giỏ hàng 

        => Mua ngay => chuyển đến trang Đặt hàng => Chuyển sang trang trạng thái 

        + Chờ xác nhận 
        + Chờ vận chuyển 
        + Đang giao 
        + Đã giao 
        + Đã hủy 

        => Nếu là người dùng thì sẽ hiển thị chỉ có đơn hàng của họ 
        => Nếu là admin thì hiển thị toàn bộ đơn hàng của khách hàng 

    + Mỗi khi mua sẽ trừ số lượng sản phẩm đi => Nêu hết rồi thì báo số lượng sản phẩm đã hết 








+ Admin (Với giao diện admin sẽ có đường dẫn riêng)
    + Sản phẩm 
        + Sắp xếp theo 
            + Mới nhất 
            + Tên 
        + Tìm kiếm đa danh mục 
        + Chi tiết : 
            + Tên 
            + Các ảnh liên quan (khung load slider ra nhiều ảnh)
                + có thể xóa mỗi ảnh của nó . 
            + Mô tả 
            + Kích thước 
            + Chất liệu 
            + Đơn giá 
            + Thời gian bảo hành 
            + Danh mục 
            => Save sản phẩm 
        + Xóa sản phẩm 

    + Kho hàng 
        + Kho 
            + List các sản phẩm 
            + Mã sản phẩm 
            + Tên sản phẩm 
            + Tổng số lượng 
            => click vào tên sản phẩm thì ra chi tiết sản phẩm 

        + Nhập hàng 
            + Mã đơn hàng 
            + Người nhập 
            + Nhà cung cấp 
            + Thành tiền
            + Ngày nhập 
            => Xem chi tiết 
                => xem chi tiết lô hàng đó và xuất hóa đơn nhập hàng 
            => Thêm nhập hàng 
                + Nhà cung cấp => Load ra tất cả các nhà cung cấp cho select box 
                + Tên sản phẩm => Load ra tất cả các tên sản phẩm cho seleect box 
                + Số lượng 
                + Giá 
                + Thuế 
            => Tìm kiếm nhập từ ngày nào đến ngày nào đó 


    + Danh mục 
        + List 
        + Thêm , sửa , xóa tên danh mục 
        + Tìm kiếm mới nhất và theo tên (gần như cái nào cũng có)

    + Nhà cung cấp 
        + Tên ncc 
        + Địa chỉ 
        + SDT 
        + Email 
        + Mã số thuế 

        => CRUD nhà cung cấp 

    + Đơn hàng 
        + Chờ xác nhận 
            + Tìm kiếm bằng mã đơn hàng hoặc tên khách hàng 
            + Mã đơn hàng 
            + Tên khách hàng 
            + Thời gian đặt 
            + Tổng giá 
            => Xem chi tiết 
            => Xác nhận 
            => Hủy đơn 

        + Chờ vận chuyển 
        + Đang giao 
        + Đã giao 


    + Thống kê 
        + Dùng charjs 
        + Thống kê theo tháng , quý , năm 
        + Chart1 
            + Doanh thu 
            + Tiền nhập hàng 

        + Chart2 
            + Tổng số đơn đang giao 
            + Đang chờ 
            + Đang chờ vận chuyển 
            + Đã giao 

        + Table 
            + Mã sản phẩm 
            + Tên sản phẩm 
            + Số lượng bán 
            + Số lượng nhập 
            + Doanh thu 

    + Khánh hàng 
        + List khách hàng 
            + Họ và tên khách hàng 
            + Số điện thoại 
            + Email 
            + Trạng thái 

        + Tìm kiếm khách hàng đa tiêu chí 
        + Khóa khách hàng => Chỉ được phép khóa tài khoản khách hàng => Không thể sửa đổi thông tin khách hàng 


    + Quản trị viên 
        + List nhân viên 
        + Tìm kiếm nhân viên đa tiêu chí 
        + Họ và tên 
        + Tên đăng nhập 
        + Email 
        + Role : Quản lý (subper admin) và nhân viên (admin)
        => LƯU 
        => XÓA 
        => Thêm mới nhân viên 
            + Tên đăng nhập 
            + Họ và tên 
            + Số điện thoại 
            + Email 
            + Địa chỉ 
            + Select chọn Nhân viên hoặc Quản lý  
        => Chỉ được phép chỉnh sửa vai trò của nhân viên là Quản lý hay Nhân viên (không chỉnh sửa được thông tin nhân viên)


+ Style + Feature 
    + Sắp xếp chỉ cần click vào tiêu đề là tự động sắp xếp mới nhất hay cũ nhất 
    => Tham khảo cái này dùng có sẵn của frontend hay phải dùng query của backend 
+ Chưa đăng nhập mà click chọn các sản phẩm thì dữ liệu đó được lưu tại localStorage . id sản phẩm , số lượng các kiểu . 



+ Test Upload file trong Postman : https://stackoverflow.com/questions/39037049/how-to-upload-a-file-and-json-data-in-postman
+ Click chọn các ảnh 

Xử lí ảnh : 
+ Lưu file từ Vuejs đến API Laravel 
    + tham khảo : https://www.youtube.com/watch?v=7dDfOTqRWCs
    + code Vuejs : 
        <form @submit.prevent="upload">
            <input type="file" @change="handleOnchange" multiple >
            <button type="submit" >Upload</button>
        </form>

        data(){
        return{
            image:''
        }

        handleOnchange(e){
            this.image = e.target.files[0];
        },
        upload(){

            const formData = new FormData;
            formData.set('image',this.image);
            BaseRequest.post('api/auth/upfile',formData)
            .then(data => {
                alert("thanh cong");
                console.log(data);
            })
            .catch(error => {
                alert('false');
                console.log(error);
            })
        }


        code Laravel : 
        public function upfile(Request $request) {
            $pathToFile = $request->file('image')->store('images','public');
            return response()->json(["message"=>"Great! Successfully upload file !"],200);
        } 

        => file được lưu vào folder của laravel /storage/app/public/images/....
        tên file được tự động ren ra (và không trùng nhau)

        $pathToFile = 'images/x1KHF4vMIsxSlqw6YtKZj2OUnkIaYV5plcVDiJS5.jpg'
        => lưu path này nào database . ảnh của sản phẩm . 

        * CHÚ Ý : Muốn lưu ảnh vào folder nào thì cứ tạo folder đó ở folder public , ví dụ products
        thì trong storage nó tự có cho mình luôn (xóa thì cũng tự xóa cho mình luôn)

+ Hiển thị file 
    + Ta không phải lấy file ra theo kiểu như lấy dữ liệu json . 
    + Ta chỉ lấy đường dẫn hiển thị file của nó ra . 

    + Ảnh ở folder public thì hiển thị ra thoải mái : ví dụ : http://127.0.0.1:8000/images/anh.png
    + Ảnh ở folder storage/app/public/images/ thì không hiển thị ra được 

    + Mà khi lưu vào thì lại lưu vào folder storage/app/public/images/ : $request->file('image')->store('images','public');

    => thì phải làm như sau mới hiển thị ra được 
        > php artisan storage:link

        => trong folder public sẽ suất hiện folder storage/images/
        => ảnh được lưu vào folder storage/app/public/images/  cũng sẽ được lưu vào folder public/storage/images/

    + => http://127.0.0.1:8000/storage/images/anh.png là link ảnh . 

    + nơi lưu trữ các thông tin liên quan đến file chính là : config/filesystems.php 
        'default' => env('FILESYSTEM_DRIVER', 'local'),
        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
        ],


    + Đọc và tìm hiểu thêm về file này : config/filesystems.php 

    + Vậy khi mà đọc dữ liệu từ database ra ta chỉ cần cộng thêm đoạn : http://127.0.0.1:8000/storage/ là có thể 
    hiển thị file đó ra cho client . 

    + file được lưu trong folder storage/app/public/images/ và public/storage/images/
    + đường dẫn được lưu trong database 
    + client hiển thị file . 

    + xóa ảnh ở folder public/storage/images/ thì ảnh ở folder storage/app/public/images/ cũng tự động xóa 
        + Và nếu muốn xóa thì phải xóa ở public/storage/images/ vì nếu xóa ở storage/app/public/images/ thì nó vẫn còn 
        ở public/storage/images/ và lúc này khi ta tiếp tục xóa ở public/storage/images/ thì nó yêu cầu phải cấp 
        quyền admin . 
        Nói chung nếu muốn xóa thì xóa ở public/storage/images/ 

    + Nói thêm : dowload file từ Client Vuejs gửi request đến API Laravel để lấy một file trong folder của laravel 
    thì dùng return response->download($path_file); => sau khi gửi xong thì file sẽ được download . 

+ Lưu nhiều ảnh cùng một lúc 
+ Chưa làm gì cả , sau khi chọn file thì lấy file đó hiển thị ra người dùng xem nhưng file mà họ đã chọn . 
    + tham khảo : https://github.com/chrissmartin/vue-upload-component
    + Ý tưởng : 

        + Chọn được nhiều ảnh cùng một lúc . 
        + Sau khi chọn ra thì hiển thị ra các ảnh được chọn . 
        + Mỗi ảnh có nút X để bỏ ảnh đó đi . 
        + Nút Submit là submit các ảnh đó lên real Server 
        + Nút Cannel là bỏ chọn . Trở lại ban đầu . 


        + Ban đầu click vào để chọn các hình ảnh . 
        + Sau khi các hình ảnh được chọn sẽ trải qua quá trình xử lí và đẩy các ảnh này lên một server fake (không phải server của mình)
            + lưu các ảnh ở đó và lấy thông tin ảnh về để hiển thị ra danh sách các ảnh mà mình đã chọn 

        + Bây giờ click bỏ chọn ảnh nào đó hoặc không sau 
        + Đến cuối cùng khi bấm submit mới lấy mảng thông tin các ảnh đó submit lên server thật của mình . 

        + Có hai mảng . Mảng các ảnh để hiển thị và mảng real để up lên server 
        + Trạng thái ban đầu của hai mảng đều là chứa tất cả các hình ảnh được chọn . 
        + Khi bỏ chọn . Mảng hiển thị bỏ chọn ảnh nào thì mảng real cũng bỏ chọn ảnh đó 
        + Đến cuối submit lên server là mảng real . 

    + Source code : 
        + src/uploadfile/file-upload.fake.service.js 

                //This is a fake upload service for local testing. 
                //You can implement your real storage service and replace this.

                function upload(formData) {
                    const photos = formData.getAll('photos');
                    const promises = photos.map((x) => getImage(x)
                        .then(img => ({
                            id: img,
                            originalName: x.name,
                            fileName: x.name,
                            url: img
                        })));
                    return Promise.all(promises);
                }

                function getImage(file) {
                    return new Promise((resolve) => {
                        const fReader = new FileReader();
                        const img = document.createElement('img');

                        fReader.onload = () => {
                            img.src = fReader.result;
                            resolve(getBase64Image(img));
                        }

                        fReader.readAsDataURL(file);
                    })
                }

                function getBase64Image(img) {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const dataURL = img.src;
                    return dataURL;
                }

                export { upload }

            => dùng nguyên văn không cần hiểu cũng được . 
            => là file để đẩy tất cả các ảnh ta đã chọn ngay từ ban đầu lên fake server sau đó lấy về để hiển thị 

        + component FilePicker.vue 
            <template>
              <div id="filepicker">
                <div class="container upload-card">
                  <!--UPLOAD-->
                  <form enctype="multipart/form-data" novalidate v-if="isInitial || isSaving">
                    <h1>Upload Files</h1>
                    <div class="dropbox">
                      <input type="file" multiple name="photos" :disabled="isSaving" 
                        @change="filesChange($event.target.name, $event.target.files); 
                        fileCount = $event.target.files.length" class="input-file">
                        
                        <p v-if="isInitial">
                          Drag your file(s) here to begin<br> or click to browse
                        </p>
                        <p v-if="isSaving">
                          Uploading {{ fileCount }} files...
                        </p>
                    </div>
                  </form>

                  <!--SUCCESS-->
                  <div v-if="isSuccess">
                    <h2>Uploaded {{ uploadedFiles.length }} file(s) successfully.</h2>

                     <!--File Previews-->
                    <div class="preview-box">
                      <div v-for="item in uploadedFiles" :key="item.id" class="img-container"> 
                           <!--File Preview-->
                        <img v-if="typecheck(item.fileName)" :src="item.url" class="preview-img" :alt="item.originalName">
                        <img v-else src="../assets/file.png" class="preview-img" :alt="item.originalName">
                        <!--Remove btn to remove individual files-->
                        <img  src="../assets/error.png" v-on:click="removeFile(fileCount,uploadedFiles.indexOf(item));" class="close" alt="Remove">
                        <!--File Name-->
                        <p v-if="fname=ftruncate(item.fileName)" style="max-width: 100px;">{{fname}}</p>
                      </div>
                    </div>
                    <!--  Submit to your storage service-->
                    <!--For now just reset() back to the main menu-->
                    <div style="display: flex;">
                    <button class="btn-cancel" v-on:click="reset()">Cancel</button>
                    <button class="btn" v-on:click="saveReal()">Submit</button>
                    </div>

                  </div>

                  <!--FAILED-->
                  <div v-if="isFailed">
                    <h2>Uploaded failed.</h2>
                    <p>
                      <a href="javascript:void(0)" @click="reset()">Try again</a>
                    </p>
                    <pre>{{ uploadError }}</pre>
                  </div>
                </div>
              </div>
            </template>

            <script>
              // swap as you need
               import { upload } from '../uploadfile/file-upload.fake.service'; // fake service
               import BaseRequest from '@/core/BaseRequest';

              const STATUS_INITIAL = 0, STATUS_SAVING = 1, STATUS_SUCCESS = 2, STATUS_FAILED = 3;

              export default {
                name: 'FilePicker',
                data() {
                  return {
                    uploadedFiles: [],
                    fileCount: 0,
                    uploadError: null,
                    currentStatus: null,
                    fname: '',
                    images:[],
                    num:0,
                  }
                },
                computed: {
                  //Upload Statuses
                  isInitial() {
                    return this.currentStatus === STATUS_INITIAL;
                  },
                  isSaving() {
                    return this.currentStatus === STATUS_SAVING;
                  },
                  isSuccess() {
                    return this.currentStatus === STATUS_SUCCESS;
                  },
                  isFailed() {
                    return this.currentStatus === STATUS_FAILED;
                  }
                },
                methods: {
                  reset() {
                    // reset form to initial state
                    this.currentStatus = STATUS_INITIAL;
                    this.uploadedFiles = [];
                    this.uploadError = null;
                  },
                  //This is where we implement the storage service
                  save(formData) {
                    this.currentStatus = STATUS_SAVING;
                    //Implement your own storage service when upload() is called.
                    //For test purposes, I added a delay service
                    upload(formData)
                     .then(x => {
                        this.uploadedFiles = [].concat(x);
                        this.currentStatus = STATUS_SUCCESS;
                      })
                      .catch(err => {
                        this.uploadError = err.response;
                        this.currentStatus = STATUS_FAILED;
                      });
                  },

                  saveReal(){
                    console.log(this.images);
                    for(var i=0;i<this.num;i++){
                      var formData = new FormData;
                      formData.set('image',this.images[i]);
                      BaseRequest.post('api/auth/upfile',formData)
                      .then(data => {
                        // alert("thanh cong");
                        console.log("thanh cong");
                        console.log(data);
                      })
                      .catch(error => {
                        alert('false');
                        console.log(error);
                      })
                    }

                  },

                  //Returns true for image data types for others false, for preview purpose
                  typecheck(oInput) {
                        var _validFileExtensions = [".jpg", ".jpeg", ".bmp", ".gif", ".png"];
                            if (oInput.length > 0) {
                                var blnValid = false;
                                for (var j = 0; j < _validFileExtensions.length; j++) {
                                    var sCurExtension = _validFileExtensions[j];
                                    if (oInput.substr(oInput.length - sCurExtension.length, sCurExtension.length).toLowerCase() == sCurExtension.toLowerCase()) {
                                        blnValid = true;
                                        break;
                                    }
                                }
                                if (!blnValid) {
                                    return false;
                                }
                            }
                     return true;
                  },
                  //Removes the selected file from the array.
                  removeFile(fileCount,key) {
                    fileCount=this.uploadedFiles.length;
                    if(fileCount === 1)
                    {
                      this.uploadedFiles.splice(key, 1);
                      this.images.splice(key, 1);
                      this.num = this.images.length;
                      this.reset();
                    }
                    else{
                      this.uploadedFiles.splice(key, 1);
                      this.images.splice(key, 1);
                      this.num = this.images.length;
                    }
                  },
                  //Func to truncate long filenames to short ones to display
                  ftruncate(n) {
                      var len = 7;
                      var ext = n.substring(n.lastIndexOf(".") + 1, n.length).toLowerCase();
                      var filename = n.replace('.'+ext,'');
                      if(filename.length <= len) {
                          return n;
                      }
                      filename = filename.substr(0, len) + (n.length > len ? '[...]' : '');
                      return filename + '.' + ext;
                  },
                  // Handle file changes
                  filesChange(fieldName, fileList) {

                    this.num = fileList.length;
                    for(var i=0;i<this.num;i++){
                      this.images[i] = fileList[i];
                    }
                    console.log(this.images);

                    const formData = new FormData();
                    if (!fileList.length) return;
                    // append the files to FormData
                    Array.from(Array(fileList.length).keys())
                      .map(x => {
                        formData.append(fieldName, fileList[x], fileList[x].name);
                      });

                    // Save it to cloud
                    this.save(formData);
                  }
                },
                mounted() {
                  this.reset();
                },
              }

            </script>

            <style>
              .upload-card{
                border-radius: 20px;
                padding: 50px 30px;
                min-height: 300px;
                min-width: 300px;

                background-color: #ffffff;
                -webkit-box-shadow: 2px 4px 20px 2px #dadada;
                box-shadow: 2px 4px 20px 2px #dadada;
                margin: auto;
                width: 50%;
              }
              .dropbox {
                margin: auto;
                width: 70%;
                background: #f8f8f8;
                border-radius: 20px;
                color: dimgray;
                padding: 10px 10px;
                min-height: 200px;
                position: relative;
                cursor: pointer;
              }
              
              .input-file {
                opacity: 0;/* invisible but it's there! */
                left: 0px; 
                width: 100%;
                height: 200px;
                position: absolute;
                cursor: pointer;
              }
              
              .dropbox:hover {
                background: #E8F5E9;
              }
              
              .dropbox p {
                font-size: 1.2em;
                text-align: center;
                padding: 50px 0;
              }
              .img-container{
                position: relative;
                display: inline-block;
                padding: 10px;
              }
              .preview-img{
                width: 80px;
                padding: 10px;
                border: 1px dotted #b3b3b39e;
              }
              .preview-box{
                display: inline-block;
              }
              .close{
                position: absolute;
                top: 0px;
                right: 0px;
                width: 20px;
              }
              .cancel{
                color: #545454;
                text-decoration: none;
              }
              .btn{
                margin: 0 auto;
                display: flex;
                justify-content: center;
                background-color: #fff;
                border: 0px;
                box-shadow: 2px 3px 12px 1px #ddd;
                border-radius: 3px;
                width: 80px;
                height: 30px;
              }
                .btn-cancel{
                margin: 0 auto;
                display: flex;
                justify-content: center;
                background-color: #f5736a;
                border: 0px;
                box-shadow: 2px 3px 12px 1px #ddd;
                border-radius: 3px;
                width: 80px;
                height: 30px;
              }
            </style>

        + Giải thích code : 
            trong data return ta sẽ tạo thêm 2 biến : num để lưu số lượng ảnh
            images là mảng để lưu ảnh . 

            + filesChange() là hàm bắt sự kiện ngay từ ban đầu ta chọn tất cả các ảnh . 
                    this.num = fileList.length;       // trong hàm này ta lưu lại tổng số ảnh được chọn 
                    for(var i=0;i<this.num;i++){      // lưu các ảnh được chọn từ mảng fileList vào mảng images 
                      this.images[i] = fileList[i];
                    }

            + removeFile(fileCount,key) {  // là hàm bắt sự kiện bỏ đi một số ảnh 
                fileCount=this.uploadedFiles.length;
                if(fileCount === 1)
                {
                  this.uploadedFiles.splice(key, 1);
                  this.images.splice(key, 1);       // mảng uploadedFiles bỏ đi ảnh nào thì mảng images cũng bỏ đi ảnh đó 
                  this.num = this.images.length;    // sau đó lưu lại giá trị num là tổng số ảnh ở thời điểm hiện tại 
                  this.reset();
                }
                else{
                  this.uploadedFiles.splice(key, 1);
                  this.images.splice(key, 1);
                  this.num = this.images.length;
                }
              },


            + code thêm hàm saveReal khi người dùng bấm submit thì chính thức upload mảng ảnh cuối cùng lên server
                saveReal(){
                    console.log(this.images);
                    for(var i=0;i<this.num;i++){
                      var formData = new FormData;
                      formData.set('image',this.images[i]);
                      BaseRequest.post('api/auth/upfile',formData)
                      .then(data => {
                        // alert("thanh cong");
                        console.log("thanh cong");
                        console.log(data);
                      })
                      .catch(error => {
                        alert('false');
                        console.log(error);
                      })
                    }

                  },

+ Muốn tìm lại file nào thì 
    + Yêu cầu phải nhớ chính xác tên file đó để tạo lại 
    => Tạo lại file đó (đúng như tên cũ của file)
    + Đứng tại file đó rồi vào TIME LINE => copy lại cái trước đó . 



+ Test API

    public function testGet(Request $request){
        print_r($request->name);
        print_r($request->id);
    }

    public function testPost(Request $request){
        print_r($request->name);
        print_r($request->id);
    }


    GET (POST) http://127.0.0.1:8000/api/auth/test-post?id=1&name=Nguyen Van Manh pro
    GET (POST) http://127.0.0.1:8000/api/auth/test-post?id=1&name=Nguyen%20Van%20Manh

    Đều cho kết quả là : 
    Nguyen Van Manh1



    - http://localhost:8080/login?id=1&name=Nguyen%20Van%20Manh
    window.location 
        .href     : "http://localhost:8080/login?id=1&name=Nguyen%20Van%20Manh"
        
        .origin   : "http://localhost:8080"
        .pathname : "/login"
        .search   : "?id=1&name=Nguyen%20Van%20Manh"
        
        .host     : "localhost:8080"
        .hostname : "localhost"
        .hash     : ""
        .port     : "8080"
        .protocol : "http:" 


    + Lấy giá trị trong Vuejs : 

        URL : http://localhost:8080/login?id=1&name=Nguyen%20Van%20Manh&age=10

        let urlParams = new URLSearchParams(window.location.search);

        console.log(urlParams.has('name')); // true // kiểm tra xem param này có hay không nếu có trả về true ngược lại là false 
        console.log(urlParams.get('name')); // Nguyen Van Manh 

        => giá trị trả về là 'Nguyen Van Manh' => không chứa % các kiểu nên có thể dùng để sử dụng trực tiếp luôn . 
        cho vào api gửi đến server các kiểu ví dụ . 

        RESTful API 
            var nameUser = urlParams.get('name');
            axios.get('http://127.0.0.1:8000/user?name='+nameUser)

        API Server 

            Route::get('user', 'App\Http\Controllers\AuthController@showInfor');

            public function showInfor(Request $request){
                $name = $request->name; 
                ... sau đó lấy biến $name này đi xử lí rồi trả về gì đó . 
            }


- https://www.lazada.vn/catalog/?q=laptop&_keyori=ss&from=input&spm=a2o4n.home.search.go.19056afey4BkKr
    + để làm cái search như trên 

    + Giả sử ban đầu : Nhập laptop => click vào nút search 
        => set lại địa chỉ window location là như này 
        => sau đó gọi hàm và gọi đến server để trả về dữ liệu 

    + Trong hàm mouted() của component có ô tìm kiếm các kiểu (hoặc đại loại là có param)
        luôn kiểm tra xem localtion sau dấu ? có giá trị gì hay không 
    ví dụ Nếu như người dùng copy paste ngay đoạn link đó 
        => cho chạy hàm mouted() kiểm tra sau dấu ? có giá trị gì hay không 
        trường hợp này sau dấu ? là có dữ liệu => lấy các dữ liệu , ví dụ lấy q=laptop 
        thì lấy laptop điền vào ô input sau đó cho thực hiện hàm giống như ta nhập vào ô input là laptop 
        rồi bấm bút search vậy 

        https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams
        https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
        + let params = (new URL(document.location)).searchParams;
            let name = params.get('name'); // is the string "Jonathan Smith".
            let age = parseInt(params.get('age')); // is the number 18

    + ?q=... trong các link tìm kiếm q viết tắt của query 

    + các bài viết tham khảo : 
        https://stackoverflow.com/questions/486896/adding-a-parameter-to-the-url-with-javascript
        https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
        https://developer.mozilla.org/en-US/docs/Web/API/URL
        https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams
        https://developer.mozilla.org/en-US/docs/Web/API/URL/searchParams

        Adding a parameter to the URL with JavaScript


        Khi nhấn nút search thì lấy giá trị đó gán cho url search 
            var url = new URL("http://foo.bar/?x=1&y=2");

            // If your expected result is "http://foo.bar/?x=1&y=2&x=42"
            url.searchParams.append('x', 42); // thêm vào 

            // If your expected result is "http://foo.bar/?x=42&y=2"
            url.searchParams.set('x', 42);  // tạo mới 


    + Giả sử mỗi lần đến một trang bằng link copy từ trước 
        thì để chạy dữ liệu như lúc ta thao tác với nó thì ta chạy trong hàm mouted()
        + Lấy tất cả các tham số sau đó chạy các hàm RESTful trong mounted() để load dữ liệu ra 
        + Mỗi lần đến bằng link copy hay tự điền thêm tham số ngay trên thanh url thì gì đi nữa 
            CUỐI CÙNG CŨNG PHẢI NHẤN ENTER để chạy link đó 
            => lúc đó hàm MOUNTED() chắc chắn được thực hiện 

    + Nên đây là cách mà để có giao diện như và dữ liệu như ý với chỉ cần copy paste link mà không cần thao tác gì . 



    + CHÚ Ý : CÓ MỘT CÁCH KHÁC THÔNG MINH HƠN VÀ GỘP 2 TH PHÍA TRÊN LẠI ĐÓ LÀ 
        + Ví dụ có trang 
            http://localhost:8080/catalog 

            + Khi người dùng nhập vào ô input : 'laptop' => bấm nút tìm kiếm 
            + Thực hiện như thường ... lấy giá trị đầu vào là 'laptop'
            + Set location trở thành là : http://localhost:8080/catalog?q=laptop 
                => link này có 2 công dụng đó là 
                    + để người dùng có thể copy paste sau này cho khỏe (khỏi phải đi nhập lại) 
                    + khi mà set location thì web browser sẽ chạy lại => hàm mounted() sẽ được thực hiện 

            + đến đây là chỉ cần code các hàm vào mounted() thôi là được . 


        + Nghĩa là code sẵn các hàm xử lí và cả những hàm get param của url vào mounted() 
        + Khi người dùng nhập 'laptop' => bấm nút tìm kiếm => set lại location => web browser được chạy lại 
            => hàm mounted() được chạy lại
        + Hoặc khi người dùng copy paste link thì => hàm mounted() cũng được chạy ngay từ đầu 
        => Suy ra trường hợp nào ta cũng có hàm mounted() chạy lại => Vậy ta có thể code toàn bộ code xử lí chỉ một lần 
        vào mounted() mà không cần code 2 lần như ví dụ ở phía trên . 

        + LƯU Ý : Khi chạy lại request lại trang (chạy lại web brower) dữ liệu của các biến hiện đang có sẽ mất 
            nên ta phải lưu vào localstorage để lát sau sử dụng lại .  
            (Vì request thì giống như chạy mới lại trang vậy)

        + Ta cũng sẽ thấy rất hợp lí trong việc lấy các giá trị từ param . 
        => Khi nhập vào 'laptop' mà request lại => toàn bộ dữ liệu sẽ mất => Ngoài việc nếu như không lưu vào localStorage 
        thì ta chỉ còn cách set nó lên param của url sau đó lần request mới này ta get các giá trị này xuống lại . 

    => Đó là cách mà chỉ cần bằng link thì vào một trang nào đó => nó cũng hiện tất cả những dữ liệu , giao diện mà 
    ta cần ra mà không cần thao tác gì thêm . 

        + Ex : 

            Copy Paste : 
                http://localhost:8080/login?name=Nguyen%20Van%20Manh&age=10

            Client Vuejs : 
                mounted(){
                    let urlParams = new URLSearchParams(window.location.search);
                    
                    if( urlParams.has('name') ) var nameUser = urlParams.get('name');
                    else var nameUser = '';

                    if( urlParams.has('age') ) var nameUser = urlParams.get('age');
                    else var ageUser = '';

                    if(nameUser != '' || ageUser != ''){
                        axios.get('http://127.0.0.1:8000/show-user?name='+nameUser+'&age='+ageUser)
                        .then(data => {
                            ... 
                        })
                        .catch(error => {
                            ...
                        })
                    }

                }

            API Server Laravel 
                Route::get('show-user', 'App\Http\Controllers\AuthController@showInfor');

                public function showInfor(Request $request){
                    $name = $request->name; 
                    $age = $request->age; 

                    $user = User::where('name',$name)->where('age',$age)->get();
                    
                    return response()->json([
                        "message" => "Great! Successfully show Information !",
                        "user" => $user;
                    ],200);
                }
            
            .... => Kiểu kiểu như thế . 


+ Push project vuejs hay laravel lên github thì nó tự bỏ đi folder node_modules và vendor rồi thêm file README.md 
    hướng dẫn cho mình (2 folder có 2 file) . 


+ Khi nhập dữ liệu vào input => thì nó đồng thời gửi request cho api lấy dữ liệu từ server đổ về 
    + Không dùng @change="" . 
        
        <input v-model="real" type="text" class="form-control" @change="testReal">
        methods:{
            testReal:function(){
                BaseRequest.get('api/auth/test-realtime?real='+this.real)
                .then(data => {
                    console.log("success");
                    console.log(data);
                })
                .catch(error => {
                    console.log('false');
                    console.log(error);
                })
            }
        }

        => Bởi vì sự kiện @change là chỉ xảy ra khi ta click ra khỏi ô input . 
        Tức là nhập : 'laptop' sau đó click ra khỏi nó mới thực hiện sự kiện . 

    + Dùng watch : 

        <input v-model="real" type="text" class="form-control" >
        watch:{
            real:function(){
                BaseRequest.get('api/auth/test-realtime?real='+this.real)
                .then(data => {
                    console.log("success");
                    console.log(data);
                })
                .catch(error => {
                    console.log('false');
                    console.log(error);
                })
            },
        },

        => Nhập vào 'laptop' thì nó bắt sự kiện đến mỗi kí tự . 
        như vậy 'laptop' => sẽ có 6 kí tự => 6 lần gọi lên server và trả về dữ liệu 
        => Sự kiện xảy ra ngay khi ta nhập dữ liệu trong ô input . 

+ Generate random url on request
    + https://laracasts.com/discuss/channels/general-discussion/generate-random-url-on-request
    + https://laravel.com/docs/9.x/urls
    + Ví dụ : 
        Route::get('/post/{post}', function (Post $post) {
            //
        })->name('post.show');

        echo route('post.show', ['post' => 1]);

        {post} này tương ứng với phần uri sẽ được random từ trước sau đó lấy ra . 

    + uri được tạo ra bằng : 
        $bytes = random_bytes(10);
        $transaction_id = (bin2hex($bytes));  // ex : 4d51d3ea0fe8df760f27

        chuỗi bao gồm 20 kí tự được tạo thành ngẫu nhiên bằng 10 chữ số và 26 chữ cái tiếng anh 
        => rất khó để trùng nhau . 


    + 
        Route::get('products/{product}', 'App\Http\Controllers\ProductController@show');

        http://127.0.0.1:8000/api/products/1

        public function show(Product $product)
        {
            return $product;
        }

        thì được : 
        {
            "id": 2,
            "name": "Áo Sơ mi",
            "quantity": 111,
            "warranty_period": "2022-09-08",
            "description": "áo đẹp",
            "category_id": 3,
            "price": 333,
            "material": "vãi",
            "dimension": "size M",
            "uri": "24f1c5c4318f4070dd22",
            "created_at": "2022-09-27T22:41:28.000000Z",
            "updated_at": "2022-09-30T22:41:28.000000Z"
        }


    + Còn dùng uri 
        Route::get('products/{uri}', 'App\Http\Controllers\ProductController@show');

        http://127.0.0.1:8000/api/products/24f1c5c4318f4070dd22

        public function show($uri)
        {
            $product = Product::where('uri', $uri)->firstOrFail();
            return $product;
        }

        ta được : 
        {
            "id": 2,
            "name": "Áo Sơ mi",
            "quantity": 111,
            "warranty_period": "2022-09-08",
            "description": "áo đẹp",
            "category_id": 3,
            "price": 333,
            "material": "vãi",
            "dimension": "size M",
            "uri": "24f1c5c4318f4070dd22",
            "created_at": "2022-09-27T22:41:28.000000Z",
            "updated_at": "2022-09-30T22:41:28.000000Z"
        }


    + Ngoài ra còn rất nhiều cái hay : tham khảo ở : https://laravel.com/docs/9.x/urls
        Ex : 
            Route::get('/category/{category}/product/{product}', function (Post $category, Comment $product) {
                //
            })->name('product.show');
             
            echo route('product.show', ['category' => 1, 'product' => 3]);
             
            // http://example.com/category/1/product/3
            => Trong tất cả các bài viết thuộc thể loại 1 => lấy ra bài viết số 3 



+ Enum là một kiểu dữ liệu đặc biệt cho phép một biến có thể là một tập hợp các hằng số định sẵn. (JAVA)
    + enum cũng có trong LARAVEL . Key : Schema Enum 
    + Rule thì là : In trong LARAVEL 


+ Tạo bảng database . Quan hệ 1-1 , 1-n , n-n trong Laravel . 
    + https://viblo.asia/p/eloquent-relationships-in-laravel-phan-1-PdbGnoEdeyA
    + https://laravel.com/docs/9.x/eloquent-relationships#one-to-many
    + https://laravel.com/docs/5.0/schema (các kiểu dữ liệu trong laravel)


    > php artisan make:model Product  -m
    > php artisan make:model Category  -m
    > php artisan make:model Image  -m

    - migrations 
        + products 
        public function up()
        {
            Schema::create('products', function (Blueprint $table) {
                $table->id();
                $table->string('name');
                $table->integer('quantity');
                $table->date('warranty_period');
                $table->longText('description');
                $table->foreignId('category_id')->nullable();
                $table->float('price');
                $table->string('material');
                $table->string('dimension');
                $table->string('uri')->unique();
                $table->timestamps();
            });
        }

        + categories 
        public function up()
        {
            Schema::create('categories', function (Blueprint $table) {
                $table->id();
                $table->string('name');
                $table->timestamps();
            });
        }

        + images 
        public function up()
        {
            Schema::create('images', function (Blueprint $table) {
                $table->id();
                $table->foreignId('product_id')->nullable();
                $table->string('image_path');
                $table->timestamps();
            });
        }


    + $table->foreignId('category_id')->nullable();
        + foreignId  : để thế này mới tạo khóa ngoại được 
        + nullable() : có thể null để khi mà xóa category nào đó thì set null mấy cột này đi sau đó mới xóa được 


    - Khóa ngoại nó không tự tạo => phải đi tạo bằng tay . 
        ALTER TABLE images ADD FOREIGN KEY(product_id) REFERENCES products(id);
        ALTER TABLE products ADD FOREIGN KEY(category_id) REFERENCES categories(id);
        
        + Khi mà có khóa ngoại trong bảng rồi thì php artisan migrate:refresh không được => nó bắt phải xóa đi hết á 


    - Model
        + Thêm vào các Model đó chỉ là để khi truy xuất , xử lý logic và dữ liệu dễ hơn thôi 
        + Product
            protected $fillable = [
                'id',
                'name',
                'quantity',
                'warranty_period',
                'description',
                'category_id',
                'price',
                'material',
                'dimension',
                'uri'
            ];

            public function images()
            {
                return $this->hasMany(Image::class);
            }

            public function category()
            {
                return $this->belongsTo(Category::class);
            } 

        + Image
            protected $fillable = [
                'id',
                'product_id',
                'image_path'
            ];

            public function product()
            {
                return $this->belongsTo(Product::class);
            }

        + Category 
            protected $fillable = [
                'id',
                'name'
            ];
            public function products()
            {
                return $this->hasMany(Product::class);
            }



WEB BÁN HÀNG (NHIỀU LOẠI HÀNG)
+ Mô tả database : 

    Table User 
    + Với User thì đăng kí - đăng nhập - quên mật khẩu - đăng nhập bằng google 

    Table Admin 
    + Với admin thì chỉ chỉ có đăng nhập - quên mật khẩu 
        + tài khoản được tạo bởi quản lí (supper admin) . tài khoản được tạo mặt định là admin (nhân viên)
        => table admin không có cột google_id 
        + admin và supper admin đều có quyền block tài khoản user đó hay không .
        + supper admin hơn admin ở chỗ là 
            + chỉnh sửa quyền admin hoặc supper admin của ai đó 
            + xóa một admin 
            + tạo mới một admin  

    + cả user và admin thì thông tin cá nhân đều chỉ có người đó chỉnh sửa .  

    Import vs Import_detail
        + Nó giống như : phiếu mượn và phiếu mượn chi tiết trong pbl3 vậy 

    Một product có thể có nhiều lần nhập kho chi tiết (import_detail)
        => thêm sản phẩm đã mới thêm nhập kho sau đó thêm nhập kho chi tiết gồm những sản phẩm nào 
        => Giống như thêm sách vs tác giả các kiểu đã mới thêm phiếu mượn và phiếu mượn chi tiết 
        => xóa sản phẩm đi thì phải set null những cái product_id đi đã (không lo mất thông tin vì ít nhất ta đã lưu lại product_name)
        => có thể xem lại phần setnull này cho pbl3 nếu muốn . 

    Shipping_address
        + user_id , recipient_name (tên người nhận) , phone_number (số điện thoại người nhận) , address (địa chỉ) 
        + mỗi người dùng có thêm 1 bảng riêng là địa chỉ ship hàng đến . Chỉ cần ntn là đủ .

    User_order 
        + recipient_name (tên người nhận) , phone_number (số điện thoại người nhận) , address (địa chỉ) 
        => các dữ liệu này sẽ được truy xuất đến bảng user dựa vào user_id sau đó lấy ra những địa chỉ hiện tại của bảng Shipping_address

        + Có nghĩa là Ex :
            + Hôm nay ta ở huế muốn order cái gì đó : 
                thì ta sẽ cho bảng Shipping_address địa chỉ là : Nguyen Van Manh - Hue - 01236000333
                => khi order hàng => các dữ liệu này sẽ vào bảng Customer_order

                1 | Nguyen Van Manh - Hue - 01236000333 | ...

            + Ngày mai ta lại muốn order một cái gì khác nhưng ta đang ở đà nẵng : 
                thì ta sẽ cho bảng Shipping_address địa chỉ là : Nguyen Van Manh - Da Nang - 01236000333

                2 | Nguyen Van Manh - Da Nang - 01236000333 | ...

            + Vậy là ta có : 

                1 | Nguyen Van Manh - Hue - 01236000333 | ...
                2 | Nguyen Van Manh - Da Nang - 01236000333 | ...

                => shipper sẽ căn cứ vào thông tin ở bảng User_order để ship hàng đến .  

    Một người đặt hàng là trừ ngay lúc đó để người sau vào không còn nữa . 

    + Số lượng nhập kho trong bảng Import_detail là khác . Và tổng số lượng trong bảng Product là khác . 
        + Trong bảng Import_detail là để in hóa đơn và sẽ cộng dồn vào số lượng trong Product . 
        + Ví dụ có 2 lần nhập kho : lần 1 nhập 50 cái laptop , lần 2 nhập 60 cái laptop 
        + Thì tổng là 110 cái laptop => mỗi lẫn bán đi được bao nhiêu cái thì trừ ra sẽ còn lại số laptop trong kho .  
            => bán 20 cái thì quantity trong Product là 90 


    + Thiết kế Login - Logout - Register - OAuth2 cho User và Admin đã 
    + Sau đó thiết kế Product - Category - Nhà cung cấp - Nhập kho - Chi tiết nhập kho cho Admin 
    + Sau đó thiết kế Order cho User .  

    - Customer (User) 
        + id
        + fullname
        + email
        + username
        + email_verified_at
        + password
        + address
        + date_of_birth
        + phone
        + gender
        + google_id
        + status (1 | 0) (1 = block , 0 = none)
        + $table->timestamps();

    - User (Admin | Supper Amin) 
        + id
        + fullname
        + email
        + username
        + email_verified_at
        + password
        + address
        + gender
        + date_of_birth
        + phone
        + url_img 
        + role (supper-admin | admin)
        + $table->timestamps();


    - Product
        + id 
        + name 
        + quantity (số lượng) (khi thêm mới sản phẩm thì có giá trị là 0, khi nhập kho thì cộng thêm và khi bán thì trừ ra)
        + warranty_period (thời gian bảo hành)
        + description 
        + category_id 
        + price 
        + material (được làm từ chất liệu gì)
        + dimension (kích thước)
        + uri (thay vì product/15 thì product/4d51d3ea0fe8df760f27 )(unique như id vậy)(được random ra) 

    -Image 
        + id 
        + product_id
        + image_path 

    - Category 
        + id 
        + name 

    
    - Provider 
        + id 
        + name    (đây là tên công ty , ví dụ VinFast)
        + address 
        + phone_number
        + email 
        + tax_id_number (mã số thuế)

    - Import 
        + id
        + importer_name (người nhập kho)
        + provider_id (id nhà cung cấp)   // được set null nếu provider bị xóa đi 
        + provider_name                   // được lấy từ name của provider (và được lưu trữ lại phòng khi provider bị xóa đi)
        + provider_tax_id (mã số thuế)    // được lấy từ tax_id_number của provider (và được lưu trữ lại phòng khi provider bị xóa đi)
        + import_date 

    - Import_detail 
        + id 
        + import_id 
        + product_id 
        + product_name 
        + quantity (số lượng)
        + price                           // giá của nhập kho chi tiết là giá nhập hàng vào còn giá ở product là giá bán ra, giá nhập vào tùy lúc có thể là lúc tăng lúc giảm, bán ra cũng vậy vào product chỉnh sửa lại giá bán ra là được  
        + tax (giá trị thuế) (%)          // tax ở bảng chi tiết lúc này không phải là mã số thuế nữa mà là giá trị thuế, bao nhiêu % đó 
                                          // chú ý một điều là nhập kho rồi thì không sửa được nên import không có sửa 
                                          // chỉ có thêm và xem .  

                                          // thêm một lô hàng thì đồng thời thêm data vào cho cả 3 bảng 
                                          // Import chứa thông tin sơ bộ 
                                          // ImportDetail chứa thông tin chi tiết 
                                          // Product -> cộng thêm số hàng được nhập vào cho cột quantity của product 

    - Shipping_address 
        + id 
        + customer_id 
        + recipient_name (tên người nhận)
        + phone_number 
        + address (địa chỉ cụ thể do người dùng nhập , nhập sao cũng được)
        + shipping_fee (là số tiền tương ứng với tỉnh thành được fix cứng ở client)
                (đúng ra phải có một bảng riêng về địa chỉ và số tiền tương ứng)

    - Customer_order 
        + id 
        + hex_id (random/4d51d3ea0fe8df760f27) (thêm cái này cho màu mè thôi , thật ra không có cũng được)
        + customer_id 
        + customer_name (lấy từ name của bảng user)
        + recipient_name (lấy từ recipient_name của bảng Shipping_address)
        + phone_number (lấy từ bảng Shipping_address)
        + address (lấy từ bảng Shipping_address)
        + order_status (1,0 : 0 là mới thêm vào giỏ hàng , chưa đặt , 1 là đã đặt hàng -> có order_time) 
        + order_time (order thì có cái này -> chuyển đến chờ xác nhận -> nếu hủy thì xóa toàn bộ đi thôi)
        + confirm_time (xác nhận thì có cái này - không hủy được nữa -> chuyển sang chờ vận chuyển )
        + ship_time  (xác nhận vận chuyển thị có cái này -> chuyển sang đang giao hàng)
        + completed_time (xác nhận đã giao thì có cái này -> hoàn thành đơn hàng)
        + shipping_fee ( số tiền vận chuyển )(mặt định bao nhiêu đó luôn ví dụ fix cứng là 1$ trên một sản phẩm , chuyến hàng có 5 sản phẩm thì phí là 5$)
            + đúng ra số tiền vận chuyển phụ thuộc vào tỉnh thành , địa chỉ là nhập sao cũng được 
            nhưng ta có một bảng cố định 64 tỉnh thành với số tiền ship tương ứng . 
            + người dùng chọn một trong các tỉnh đó cho một đơn hàng 

            + Hoặc có một cách khác đó là 
            lưu một mảng gồm các object có 2 thuộc tính bao gồm tên tỉnh và số tiền ship tương ứng 
            select v-model giá trị tiền . click vào tỉnh nào thì lấy giá trị tiền 
            cho vào giá trị tiềng ship  

            + còn không thì fix cứng cũng được , chức năng này để tối ưu sau , sau này code thêm . 
            + khi tính tổng tiền của hiện bao nhiêu tiền ship ra đó cho người dùng . 

            => Nếu chọn cách fix cứng thì . trên mỗi sản phẩm lấy phí ship 1$ . 
            shipping_fee là tổng số tiền ship hàng của chuyến hàng đó . 
            Mỗi lần thêm vào giỏ hàng thì tổng kết lại giỏ hàng đó có bao nhiêu sản phẩm 
            từ đó ra được tiền ship và update vào cột shipping_fee
                + Trong bảng User_order chỉ tồn tại 2 thể loại 
                1 là : order_status : 1 => tức là những hàng hóa được chốt đơn rồi 
                    => ta không quan tâm phí ship nữa vì nó được chốt rồi , ta chỉ quan tâm các trường 
                    thời gian của nó 

                2 là . Mỗi customer chỉ có tối đa duy nhất một 
                hàng dữ liệu có id của họ mà có order_status : 0 => 
                tức là đang nằm trong giỏ hàng , tất cả những sản phẩm của hàng dữ liệu này 
                có customer_id của ai đó , có id của bảng user_order và có status_order là 0 . 
                Vì mỗi người chỉ có một giỏ hàng duy nhất . 
                => nên chắc chắn mỗi customer chỉ có tối đa một hàng dữ liệu trong user_order 
                mà có customer_id của mình có status_order là 0 . 
                => ta chỉ việc lấy id người dùng => where customer_id = id and status_order = 0 
                => lấy ra được id của user_order thoả mãn đó => truy xuất order_detail 
                thêm xóa sửa các kiểu sau đó tổng lại số tiền ship .   

    - Order_detail 
        + id 
        + customer_order_id
        + product_id 
        + product_name 
        + quantity
        + price 

- Xác định loại dữ liệu và tạo migrate cho các bảng . Ta sẽ tạo Migrate tương ứng với Model luôn
- Test product/4d51d3ea0fe8df760f27 ( product/{product} ) 
    + Tạo bảng product 
    + Tạo id ngẫu nhiên 
    + Lưu ảnh 
    + Ứng với mỗi url của product thì trả về thông tin của product đó . 


+ Xóa file 
    + https://stackoverflow.com/questions/33842735/how-to-delete-file-from-public-folder-in-laravel-5-1

    use Illuminate\Support\Facades\File;
    File::delete($filename);

    File::delete('storage/images/qkcEaHIDOOY5rX2RspQy5jmI7XQpsqMHjRYWMZB3.jpg');

    + Khi chỉnh sửa . Để cho dễ thì mình sẽ chia ra 2 phần
        + Một phần như là phần thêm mới (không chứa gì cả để cho người dùng có thể thêm mới như lúc mới tạo product)
        + Một phần là hiển thị ra tất cả những ảnh cũ , phần xóa đi những ảnh không cần (phần này tự code)
            => click vào dáu X của ảnh nào thì ẩn ảnh đó đi và lưu lại path của ảnh đó 
            => sau cuối khi người dùng submit thì ta sẽ dùng url đó để submit ảnh đó đi . 


        + Ta có thể chia ra làm 3 hàm 
        + Khi submit 
            + /product/24f1c5c4318f4070dd22
                => hoặc là ta dùng uri này để where ra id của product này hoặc là /product/24f1c5c4318f4070dd22?id=...
                    sau đó $request->id là lấy dược id 
                => gửi formData các ảnh lên và lưu ảnh vào folder public 
                => lưu url các ảnh của product tương ứng vào bảng images tương ứng với id lấy được như trên 

            + gửi thông tin lên => và lưu các thông tin khác 
            + xóa các ảnh (nếu có khi cập nhật)(còn khi tạo mới product thì không dùng hàm này)
                lưu một mảng các path ảnh cần xóa sau đó lặp ra từng cái và xóa nó . 

            + Ex : 
                Route::post('upfile', 'App\Http\Controllers\AuthController@upfile');
                http://127.0.0.1:8000/api/auth/upfile

                JSON : 
                    {
                        "images":["a1","b2","c3"]
                    }

                return $request->images;

                trả về : 
                    [
                        "a1",
                        "b2",
                        "c3"
                    ]




+ main.js in Vuejs 
    + 
        // import App from './App.vue'
        import UserComp from './components/User'

        // const app = createApp(App);
        const app = createApp(UserComp);

        => thay vì chạy file App đầu tiên thì ta chạy file UserComp đầu tiên . 

        + Nếu như chạy file App đầu tiên thì '/' mặt định là của file App
        + Còn nếu như ta đổi lại chạy file UserComp đầu tiên thì '/' sẽ trở thành Page Not Found 


+ window.location = window.location.href;
    => yêu cầu request lại trang một cách dễ dàng . 


+ watch: {
      isOpened() {
        window.document.body.style.paddingLeft = this.isOpened && this.isPaddingLeft ? this.menuOpenedPaddingLeftBody : this.menuClosedPaddingLeftBody
      }
    }

    => cách set khoảng cách và chỉnh style trong vuejs 

      <i style="color: #0085FF;" class="bx" :class="isOpened ? 'bx-menu-alt-right' : 'bx-menu'" id="btn" @click="isOpened = !isOpened"/>

        <span>
            <li>
              <a data-toggle="collapse" href="#collapseExample" role="button" aria-expanded="false" aria-controls="collapseExample"><i class="fa-solid fa-boxes-stacked"></i><span class="links_name">Warehouse</span></a>
              <span class="tooltip">Warehouse</span>

              <div class="collapse" id="collapseExample" style="margin-left: 30px;">
                <div class="line"></div>
                <span>
                  <li>
                    <a><i class="fa-solid fa-list"></i><span class="links_name">Category</span></a>
                    <span class="tooltip">Category</span>
                  </li>
                </span>

                <div class="line"></div>
                <span>
                  <li>
                    <a><i class="fa-solid fa-list"></i><span class="links_name">Category</span></a>
                    <span class="tooltip">Category</span>
                  </li>
                </span>
              </div>

            </li>
        </span>

        watch: {
            isOpened() {
                window.document.body.style.paddingLeft = this.isOpened && this.isPaddingLeft ? this.menuOpenedPaddingLeftBody : this.menuClosedPaddingLeftBody
                var collapseExample = window.document.getElementById('collapseExample');
                if(this.isOpened == false){
                  collapseExample.style='margin-left: 0px;';
                }
                if(this.isOpened == true){
                  collapseExample.style='margin-left: 30px;';
                }
            }
        }

        => khi click nút 3 gạch thì cho gái trị isOpened thay đổi từ true <=> false 
            ta sẽ watch giá trị đó để điều chỉnh kích thước cho hợp lý => hiển thị đẹp hơn . 


+ Nhiều loại input (hay)(ngày tháng , tệp,thanh kéo...)
    + https://getbootstrap.com/docs/4.0/components/input-group/
    + https://bootstrap-vue.org/docs/components/form-input

+ Vue notification
    + https://madewithvuejs.com/notification
    + https://www.npmjs.com/package/vue-notification
    + https://codesandbox.io/s/i74t0?file=/src/App.vue
    + https://www.npmjs.com/package/vue-notification


    + Cài đặt : 
    + npm i vue3-vt-notifications
    + npm i tailwindcss@1.8.7

    + main.js  
        import Notifications from "vue3-vt-notifications";
        import "tailwindcss/dist/tailwind.css";
        app.use( Notifications )

    + package.json 
        + "tailwindcss": "^1.8.7",
        + "vue3-vt-notifications": "^1.0.1",

    + App.vue 
        <template>
          <div id="app" class="bg-red-400 min-h-screen flex justify-center align-center flex-col">
            <div class="flex justify-center space-x-5">
              <button
                class="w-54 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                @click="onClickTop"
              >Top notification</button>
              <button
                class="w-54 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                @click="onClickBot"
              >Bottom notification</button>
            </div>
            <notificationGroup group="top">
              <div class="fixed inset-0 flex px-4 py-6 pointer-events-none p-6 items-start justify-end">
                <div class="max-w-sm w-full">
                  <notification v-slot="{notifications}">
                    <div
                      class="flex max-w-sm w-full mx-auto bg-white shadow-md rounded-lg overflow-hidden mt-4"
                      v-for="notification in notifications"
                      :key="notification.id"
                    >
                      <div class="flex justify-center items-center w-12 bg-green-500">
                        <svg
                          class="h-6 w-6 fill-current text-white"
                          viewBox="0 0 40 40"
                          xmlns="http://www.w3.org/2000/svg"
                        >
                          <path
                            d="M20 3.33331C10.8 3.33331 3.33337 10.8 3.33337 20C3.33337 29.2 10.8 36.6666 20 36.6666C29.2 36.6666 36.6667 29.2 36.6667 20C36.6667 10.8 29.2 3.33331 20 3.33331ZM16.6667 28.3333L8.33337 20L10.6834 17.65L16.6667 23.6166L29.3167 10.9666L31.6667 13.3333L16.6667 28.3333Z"
                          ></path>
                        </svg>
                      </div>

                      <div class="-mx-3 py-2 px-4">
                        <div class="mx-3">
                          <span class="text-green-500 font-semibold">{{notification.title}}</span>
                          <p class="text-gray-600 text-sm">{{notification.text}}</p>
                        </div>
                      </div>
                    </div>
                  </notification>
                </div>
              </div>
            </notificationGroup>
            <notificationGroup group="bottom" position="bottom">
              <div
                class="fixed inset-x-0 bottom-0 flex px-4 py-6 pointer-events-none p-6 items-start justify-end"
              >
                <div class="max-w-sm w-full">
                  <notification v-slot="{notifications}">
                    <div
                      class="flex max-w-sm w-full mx-auto bg-white shadow-md rounded-lg overflow-hidden mt-4"
                      v-for="notification in notifications"
                      :key="notification.id"
                    >
                      <div class="flex justify-center items-center w-12 bg-red-500">
                        <svg
                          class="h-6 w-6 fill-current text-white"
                          viewBox="0 0 40 40"
                          xmlns="http://www.w3.org/2000/svg"
                        >
                          <path
                            d="M20 3.36667C10.8167 3.36667 3.3667 10.8167 3.3667 20C3.3667 29.1833 10.8167 36.6333 20 36.6333C29.1834 36.6333 36.6334 29.1833 36.6334 20C36.6334 10.8167 29.1834 3.36667 20 3.36667ZM19.1334 33.3333V22.9H13.3334L21.6667 6.66667V17.1H27.25L19.1334 33.3333Z"
                          ></path>
                        </svg>
                      </div>

                      <div class="-mx-3 py-2 px-4">
                        <div class="mx-3">
                          <span class="text-red-500 font-semibold">{{notification.title}}</span>
                          <p class="text-gray-600 text-sm">{{notification.text}}</p>
                        </div>
                      </div>
                    </div>
                  </notification>
                </div>
              </div>
            </notificationGroup>
          </div>
        </template>

        <script>
        export default {
          name: "App",
          methods: {
            onClickTop() {
              this.$notify(
                {
                  group: "top",
                  title: "Success",
                  text: "Your account was registered!"
                },
                4000
              );
            },
            onClickBot() {
              this.$notify(
                {
                  group: "bottom",
                  title: "Error",
                  text: "Your email is already used!"
                },
                4000
              );
            }
          }
        };
        </script>

        <style>
        #app {
          font-family: "Avenir", Helvetica, Arial, sans-serif;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        }
        </style>


    + Gửi sự kiện lỗi từ component Login sang component Notifications
    + Login.vue 
        methods: {
            login:function(){
                console.log(this.loginAdmin);
                var v = this.loginAdmin;
                LoginRequest.post('api/auth/login',this.loginAdmin)
                .then( data => {
                    alert("Đăng nhập thành công !");
                    window.localStorage.setItem('admin',JSON.stringify(data));
                    this.$router.push({name:'DashboardAdmin'}); 
                    this.error = null ;
                    window.location=window.location.href;
                })
                .catch( error => {
                    this.loginAdmin = v; // để nó không reset ô input đi . 
                    this.error = error;

                    const { emitEvent } = useEventBus();   ///+++ khai báo biến 
                    emitEvent('eventError',error.response.data.error);   ///+++ phát sự kiện eventError và gửi lỗi đi 

            })
        }

    + Notification.vue 
        <template>
          <div>
            <!-- <div id="app" class="bg-red-400 min-h-screen flex justify-center align-center flex-col"> -->
              <!-- <div class="flex justify-center space-x-5">
                <button
                  class="w-54 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                  @click="onClickTop"
                >Top notification</button>
                <button
                  class="w-54 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                  @click="onClickBot"
                >Bottom notification</button>
              </div> -->
              <notificationGroup group="top">
                <div class="fixed inset-0 flex px-4 py-6 pointer-events-none p-6 items-start justify-end">
                  <div class="max-w-sm w-full">
                    <notification v-slot="{notifications}">
                      <div
                        class="flex max-w-sm w-full mx-auto bg-white shadow-md rounded-lg overflow-hidden mt-4"
                        v-for="notification in notifications"
                        :key="notification.id"
                      >
                        <div class="flex justify-center items-center w-12 bg-green-500">
                          <svg
                            class="h-6 w-6 fill-current text-white"
                            viewBox="0 0 40 40"
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d="M20 3.33331C10.8 3.33331 3.33337 10.8 3.33337 20C3.33337 29.2 10.8 36.6666 20 36.6666C29.2 36.6666 36.6667 29.2 36.6667 20C36.6667 10.8 29.2 3.33331 20 3.33331ZM16.6667 28.3333L8.33337 20L10.6834 17.65L16.6667 23.6166L29.3167 10.9666L31.6667 13.3333L16.6667 28.3333Z"
                            ></path>
                          </svg>
                        </div>
          
                        <div class="-mx-3 py-2 px-4">
                          <div class="mx-3">
                            <span class="text-green-500 font-semibold">{{notification.title}}</span>
                            <p class="text-gray-600 text-sm">{{notification.text}}</p>
                          </div>
                        </div>
                      </div>
                    </notification>
                  </div>
                </div>
              </notificationGroup>
              <notificationGroup group="bottom" position="bottom">
                <div
                  class="fixed inset-x-0 bottom-0 flex px-4 py-6 pointer-events-none p-6 items-start justify-end"
                >
                  <div class="max-w-sm w-full">
                    <notification v-slot="{notifications}">
                      <div
                        class="flex max-w-sm w-full mx-auto bg-white shadow-md rounded-lg overflow-hidden mt-4"
                        v-for="notification in notifications"
                        :key="notification.id"
                      >
                        <div class="flex justify-center items-center w-12 bg-red-500">
                          <svg
                            class="h-6 w-6 fill-current text-white"
                            viewBox="0 0 40 40"
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d="M20 3.36667C10.8167 3.36667 3.3667 10.8167 3.3667 20C3.3667 29.1833 10.8167 36.6333 20 36.6333C29.1834 36.6333 36.6334 29.1833 36.6334 20C36.6334 10.8167 29.1834 3.36667 20 3.36667ZM19.1334 33.3333V22.9H13.3334L21.6667 6.66667V17.1H27.25L19.1334 33.3333Z"
                            ></path>
                          </svg>
                        </div>
          
                        <div class="-mx-3 py-2 px-4">
                          <div class="mx-3">
                            <span class="text-red-500 font-semibold">{{notification.title}}</span>
                            <p class="text-gray-600 text-sm">{{notification.text}}</p>
                          </div>
                        </div>
                      </div>
                    </notification>
                  </div>
                </div>
              </notificationGroup>
            <!-- </div> -->
          </div>
          </template>
          
          <script>
        import useEventBus from '../../composables/useEventBus'

          export default {
            name: "NotificationComp",
            mounted(){
              const { onEvent } = useEventBus()
              onEvent('eventError',(meassage)=>{ // Bắt sự kiện eventError
                this.$notify(
                  {
                    group: "bottom",
                    title: "Error",
                    text: meassage
                  },
                  4000
                );
                })
            },
            methods: {
              onClickTop() {
                this.$notify(
                  {
                    group: "top",
                    title: "Success",
                    text: "Your account was registered!"
                  },
                  4000
                );
              },
              onClickBot() {
                this.$notify(
                  {
                    group: "bottom",
                    title: "Error",
                    text: "Your email is already used!"
                  },
                  4000
                );
              }
            }
          };
          </script>
          
          <style>
          #app {
            font-family: "Avenir", Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
          }
          </style>


+ Phát sự kiện thực hiện thành công và dừng lại vài giây để hiện thị thông báo 
    +           
        .then( data => {
            window.localStorage.setItem('admin',JSON.stringify(data));
            this.error = null ;

            const { emitEvent } = useEventBus();
            emitEvent('eventSuccess','Đăng nhập thành công !');

            setTimeout(()=>{
              this.$router.push({name:'DashboardAdmin'}); 
              window.location=window.location.href;
            }, 3000);
        }

    + 
        Nếu ta dùng alert("Đăng nhập thành công !");
        => nó sẽ hiện ra thông báo thành công => (có thời gian dừng để ta click vào đó để tiếp tục)

    + Nếu dùng Notification thì nó có thông báo nhưng ta không biết bởi vì khi thành công thì nó chuyển từ Login sang trang 
        khác luôn 
        => ta phải dừng lại khoảng vài giây để cho nó hiện thông báo lên đã rồi chuyển tiếp 



+ Administrator.vue 
    => vuejs không cho đặt tên file này 


+ Thiết kế cho Admin và User 
    + mỗi bên 2 file BaseRequest.js và LoginRequest.js cho khỏe . 



+ PATCH EDIT ERROR 
{
    "fullname": [
        "The fullname must be a string.",
        "The fullname must be between 2 and 100 characters."
    ],
    "email": [
        "The email must be a string.",
        "The email must be a valid email address."
    ],
    "username": [
        "The username must be a string."
    ],
    "address": [
        "The address must be a string.",
        "The address must be at least 1 characters."
    ],
    "phone": [
        "The phone must be at least 9.",
        "The phone must be a number."
    ],
    "age": [
        "The age must be a number.",
        "The age must be at least 18."
    ]
}

+ Chạy nhiều câu lệnh cùng lúc trong : terminal 
    + 
        php artisan make:controller CategoryController
        php artisan make:controller ProductController
        php artisan make:controller ResetPasswordController
        php artisan make:controller SendEmailController

    + 
        npm i bootstrap 
        npm i jquery 

    => copy hết rồi paste một lần là nó tự thực hiện các câu lệnh (câu nào lỗi thì nó không thực hiện và thực hiện lệnh tiếp theo)
    => cho đến lệnh cuối cùng thì ta ENTER cái nữa để nó thực hiện lệnh cuối là xong . 



+ 
    php artisan make:notification ResetPasswordRequest
    php artisan make:model PasswordReset

    php artisan make:controller ResetPasswordController
    php artisan make:controller SendEmailController


+

    php artisan make:model Admin -m -c  
    php artisan make:model Product -m -c  
    php artisan make:model Category -m -c  
    php artisan make:model Image  -m -c
    php artisan make:model Provider -m -c  
    php artisan make:model Import -m -c  
    php artisan make:model ImportDetail -m -c  
    php artisan make:model ShippingAddress -m -c  
    php artisan make:model UserOrder -m -c  
    php artisan make:model OrderDetail -m -c


+ Đăng nhập bằng 2 bảng User và Admin . 
    + Từ khóa : How to Use Multi Authentication JWT API using Laravel 8?
    + https://www.mywebtuts.com/blog/how-to-use-multi-authentication-api-using-laravel-8
    + https://tutspack.com/multiple-api-authentication-using-jwt-in-laravel-9/
    + https://github.com/AR-Shahin/Laravel_Auth
    + https://github.com/AR-Shahin/Laravel_Auth/tree/main/jwt
    + https://www.nicesnippets.com/blog/laravel-8-multi-authentication-api-tutorial (đọc thêm)


+ Login Auth use JWT in Laravel 8 
    + 1 bảng : User 
        + https://github.com/camposgaston/Laravel-8-JWT-API 
    
    + 2 bảng : User and Admin 
        + https://github.com/AR-Shahin/Laravel_Auth/tree/main/jwt
        + https://tutspack.com/multiple-api-authentication-using-jwt-in-laravel-9/


+ 2 bảng 
    + Vừa phù hợp mới mình muốn code theo kiểu bảng customer cho người dùng đăng nhập vào client 
    + Bảng user (admin | supper admin) cho admin thêm xóa sửa sản phẩm . 
    + Chịu khó ban đầu tìm source và các bài viết để đọc thôi chứ sau này khi mà bảng của customer và bảng của user (admin)
        tách bạch ra thì rất là khỏe 
        + vì mỗi người chỉ có một email , nhỡ customer và user cùng một người thì chỉ có 1 email thôi 
            chỉ có 1 email mà cần có 2 tài khoản (cả customer và user) => khó làm 
        + bảng user cần có thêm gooogle_id  
        + mỗi tài khoản chỉ đăng nhập với email và password tương ứng  



+ download 1 folder trong toàn bộ source của github : 
    + https://minhaskamal.github.io/DownGit/#/home
    + https://stackoverflow.com/questions/7106012/download-a-single-folder-or-directory-from-a-github-repo (đọc thêm)

+ Không nên comment trong json khi restful trong postman => cũng có thể gây lỗi 
+ Ngay tại client Vuejs kiểm tra role của account nếu như không phải là supper admin thì ẩn 
bảng quản lí admin đi liền . Như thế thôi cũng được 
Còn không muốn chắc chắn hơn nữa thì trong json ta lại kiểm tra rolelogin tiếp 

+ $users = User::where('id','!=',$request->idlogin)->get(); // lấy tất cả ngoại trừ cái đứa đăng nhập 

+ public function up()
    {
        Schema::create('password_resets', function (Blueprint $table) {
            $table->string('email')->index();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
            $table->timestamp('updated_at')->nullable();
        });
    }

    => nhớ vào cái này thêm cột để gửi mail 
            $table->id();
            $table->timestamp('updated_at')->nullable();

+ Đầy đủ là : 
        Schema::create('password_resets', function (Blueprint $table) {
            $table->id();
            $table->string('email')->index();
            $table->string('token');
            $table->timestamp('updated_at')->nullable();
            $table->timestamp('created_at')->nullable();
        });

+ Nếu thêm cột => migrate:refresh => xóa dữ liệu và trong folder migrate thêm nhiều file nữa => ta có thể làm cách khác : 
    + code thêm cột vào file migrate của bảng tương ứng 
    + vào phpmyadmin thêm cột bằng tay cho nó (nhớ là phải đúng kiểu dữ liệu)

+ $passwordReset = PasswordReset::updateOrCreate([
    => cập nhật hoặc tạo 



- Use Multi Authentication JWT API using Laravel 8
    + https://tutspack.com/multiple-api-authentication-using-jwt-in-laravel-9/ (bài viết gốc)
    + https://github.com/AR-Shahin/Laravel_Auth/tree/main/jwt (source code gốc)

    + 
        php artisan make:model Product -m -c
        php artisan make:model Customer -m -c
        composer require tomfordrumm/jwt-auth:dev-develop
        composer require laravel/sanctum

    + php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider"
    + php artisan jwt:secret
        => sau đó trong .env sẽ tự có thêm dòng : 
        JWT_SECRET=cwreySsAfthkFUHCAJmlAIhNEqBshrGGOchMDyvN1u1sNz4id1VehVXT66c5o9Ti
          
    + config/app.php
        'providers' => [
            ...
            Tymon\JWTAuth\Providers\LaravelServiceProvider::class, ///+++ thêm dòng này vào providers
        ]  


    + config/auth.php 
        <?php

        return [

            'defaults' => [
                'guard' => 'web',
                'passwords' => 'users',
            ],


            'guards' => [
                'web' => [
                    'driver' => 'session',
                    'provider' => 'users',
                ],
                'admin_api' => [
                    'driver'   => 'jwt',
                    'provider' => 'users',
                ],
                'customer_api' => [
                    'driver'   => 'jwt',
                    'provider' => 'customers',
                ],
            ],


            'providers' => [
                'users' => [
                    'driver' => 'eloquent',
                    'model' => App\Models\User::class,
                ],
                'customers' => [
                    'driver' => 'eloquent',
                    'model' => App\Models\Customer::class,
                ],
            ],


            'passwords' => [
                'users' => [
                    'provider' => 'users',
                    'table' => 'password_resets',
                    'expire' => 60,
                    'throttle' => 60,
                ],
            ],

            'password_timeout' => 10800,

        ];


    + Code vào Model User.php , Customer.php . Controller AuthController.php , CustomerAuthController.php 
    + Code các Route của API vào file api.php 

    + 2 Table : 
        Database             Model       Controller                 Migrate               Middleware            
        users                User        AuthController             create_users          admin_api
        customers            Customer    CustomerAuthController     create_customers      customer_api

        Dùng chung file password_reset để quên mật khẩu 
            Code gửi Mail của user là của Laravel của customer là tự code . 
            (Thực ra cái nào cũng là do mình code cả đều một bên là dùng cái có sẵn của laravel một bên là tự code)

        Middleware
            Toke của User     thì chỉ áp dụng được cho admin_api
            Toke của Customer thì chỉ áp dụng được cho customer_api 
            (Không dùng token này cho cái kia được )

- Cách thức hoạt động của quên mật khẩu bằng email . 
    + Hash ra một token => lưu token này cho email tương ứng cần quên mật khẩu 
    => lưu vào bảng password_reset trong database 

    + Gửi mail đến kèm token => người dùng click vào link => mang theo token => client lấy token 
    => gửi lên lại để xác thực với token đã lưu trong database nếu là cùng một token => cùng một người => đổi mật khẩu được 

    => quên mật khẩu của Laravel đang hoạt động theo cơ chế này 
    => Ta hoàn toàn có thể làm giống Laravel được . 
        Token được hash ra . Email người dùng gửi lên . 
        Chỉ cần có một bảng để lưu email và token .  
        Cần thêm tính năng gửi email trong laravel là xong . 

    - Hiện tại bảng User (Admin | Supper Admin) đang dùng của Laravel 
    - Bảng customer làm tương tự nhưng đến hàm notify() thì lỗi không thực hiện được . Nên 
        công đoạn gửi Mail không được => nên mình tự đi code cái này . Còn lại y hệt . 

    - Bảng password_resets dùng chung cho cả User và Customer vì nó chỉ có chức năng là lưu email và token chứ 
        không có gì cả . 

- Forgot password cho Admin 
    + https://viblo.asia/p/reset-password-voi-laravel-passport-authentication-api-rest-V3m5Wbr7lO7
    + 
        php artisan make:notification ResetPasswordRequest
        php artisan make:model PasswordReset
        php artisan make:controller ResetPasswordController

    + Thêm các cột tương ứng bằng phpmyadmin (nếu thiếu)
        public function up()
        {
            Schema::create('password_resets', function (Blueprint $table) {
                $table->id();
                $table->string('email')->index();
                $table->string('token');
                $table->timestamp('updated_at')->nullable();
                $table->timestamp('created_at')->nullable();
            });
        }

    + api : 
        // Admin
        Route::prefix('admin')->controller(AuthController::class)->group(function () { 

            ....

            Route::post('reset-password', 'App\Http\Controllers\ResetPasswordController@sendMail');
            Route::put('reset-password/{token}', 'App\Http\Controllers\ResetPasswordController@reset');

            Route::middleware('auth:admin_api')->group(function () { 
            
                ....
            
            });
        });

        // Customer 
        Route::prefix('customer')->controller(CustomerAuthController::class)->group(function () {

            ....

            Route::post('reset-password', 'App\Http\Controllers\ResetPasswordController@sendMail2');
            Route::put('reset-password/{token}', 'App\Http\Controllers\ResetPasswordController@reset2');

            Route::middleware('auth:admin_api')->group(function () {

                ....

            });
        });


        - Tất cả đều phải nằm ngoài middleware vì nó không yêu cầu đăng nhập (không yêu cầu Authentizion) 
            (quên mật khẩu thì đăng nhập kiểu gì)


    - BƯỚC 1 : LƯU EMAIL , TOKEN VÀO DATABASE SAU ĐÓ GỬI MAIL MANG TOKEN 
    + ResetPasswordController
        // Admin Forgot Password by Email
        public function sendMail(Request $request,User $user)
        {
            $user = User::where('email', $request->email)->firstOrFail();
            $passwordReset = PasswordReset::updateOrCreate([
                'email' => $user->email,
            ], [
                'token' => Str::random(60),
            ]);
            if ($passwordReset) {
                $user->notify(new ResetPasswordRequest($passwordReset->token));
            }
      
            return response()->json([
            'message' => 'We have e-mailed your password reset link!'
            ]);
        }

        public function reset(Request $request, $token)
        {
            $passwordReset = PasswordReset::where('token', $token)->firstOrFail();
            if (Carbon::parse($passwordReset->updated_at)->addMinutes(720)->isPast()) {
                $passwordReset->delete();

                return response()->json([
                    'message' => 'This password reset token is invalid.',
                ], 422);
            }
            $user = User::where('email', $passwordReset->email)->firstOrFail();
            $updatePasswordUser = $user->update(['password' => bcrypt($request->password)]);
            $passwordReset->delete();

            return response()->json([
                'success' => $updatePasswordUser,
                "message" => "Đổi mật khẩu thành công !"
            ]);
        }

    
        => POST : http://127.0.0.1:8000/api/admin/reset-password
            {
                "email":"nguyenvanmanh2001it1@gmail.com"
            }

        => $passwordReset = PasswordReset::updateOrCreate([  // CẬP NHẬT HOẶC TẠO MỚI MỘT HÀNG DỮ LIỆU BAO GỒM (email và token)
        => Gọi đến hàm sendMail => random ra một token gọi hàm notify và khai báo ResetPasswordRequest đồn thời truyền vào token 

    + ResetPasswordRequest
        public function __construct($token)
        {
            $this->token = $token; // HÀM KHỞI TẠO __construct NHẬN GIÁ TRỊ TOKEN 
        }

        public function via($notifiable)
        {
            return ['mail'];
        }

        public function toMail($notifiable)
        {
            $url = url('http://localhost:8080/admin/reset-password?token=' . $this->token);
            
            return (new MailMessage)
                ->line('You are receiving this email because we received a password reset request for your account.')
                ->action('Reset Password', url($url))
                ->line('If you did not request a password reset, no further action is required.');
        }


        $url sẽ là đường dẫn đến Client Vuejs để Client lấy token . Sau này update lên heroku thì nhớ đổi 
            localhost:8080 thành domain . 

        => Khởi tạo biến MailMessage gọi các hàm line,action,line và truyền vào các nội dung . Trong đó có $url mang token 

    + Mail này được gửi đến email của người dùng => người dùng click vào đó => hết bước 1 . 

    - BƯỚC 2 : XÁC THỰC TOKEN Ở CLIENT VỚI TOKEN ĐƯỢC LƯU TRONG DATABASE . 

        + Token sẽ được gắn vào và trở thành và được PUT lên 
            PUT : http://127.0.0.1:8000/api/admin/reset-password/cDnWLkqeEcJqxy3yIAuhBnHMoDHf6dYtUkluwQpaKbRlQbzRz6uk3fNdt0L1
                {
                    "password":"newpassword"
                }

    => GỌI HÀM reset
            $passwordReset = PasswordReset::where('token', $token)->firstOrFail();
            Lấy ra biến $passwordReset có token là $token . (Biến này thì cũng giống như một product hay user thôi)
            (mang toàn bộ thông tin của dòng dữ liệu đó)(mảng cả email)
        => Nếu token đúng => đi đổi mật khẩu . Nếu sai thì báo sai . 
        => Nếu mà đúng thì 
            $user = User::where('email', $passwordReset->email)->firstOrFail(); // Lấy ra User có email đó 
            $updatePasswordUser = $user->update(['password' => bcrypt($request->password)]); // Đổi mật khẩu mà user muốn đổi . 

    => QUÊN MẬT KHẨU CHO ADMIN ĐÃ XONG 



- Forgot password cho Customer 
    + Mọi thứ ý hệ chỉ khác là phải tự code đoạn gửi Mail 

    + >php artisan make:mail NotifyMail
    + NotifyMail
        class NotifyMail extends Mailable
        {
            use Queueable, SerializesModels;
         
            public $token;
            public function __construct($_token)
            {
                //
                $this->token = $_token;

            }
         
            public function build()
            {
                $url = url('http://localhost:8080/admin/reset-password?token=' . $this->token);
                return $this->view('emails.contentMail',['__url' => $url]);
            }
        }

        => GIỐNG Y HỆT LARAVEL , cũng truyền token vào hàm __construct các kiểu . Chỉ là mình tự code . 
        => $url mang token gửi truyền vào file views/emails/contentMail.blade.php dưới tên biến là __url
        => trong file views/emails/contentMail.blade.php
            <a href="{{$__url}}">{{$__url}}</a><br>
            => nhận giá trị ra và sử dụng . 
            => Đây cũng là cách mà truyền giá trị từ Controller đến View 
            => Database <=> Model <=> Controller (use Model) <=> View (Web)(get Data)
            => Database <=> Model <=> Controller (use Model) <=> API (get Data return JSON)

    + Cấu hình cho gửi được email (đã nói xem lại ở phía trên)

        // gui mail cho customer 
        use Mail;
        use App\Mail\NotifyMail;
        use Exception;

        public function sendmailCustomer($token,$email) { // HÀM SEND MAIL TỰ CODE  
            Mail::to($email)->send(new NotifyMail($token));
            if (Mail::failures()) return response()->json(["message"=>"Sorry ! Please try again latter"],400);
            else return response()->json(["message"=>"Great! Successfully send in your mail"],200);
        } 

        public function sendMail2(Request $request,Customer $customer)
        {
            $customer = Customer::where('email', $request->email)->firstOrFail();
            $passwordReset = PasswordReset::updateOrCreate([
                'email' => $customer->email,
            ], [
                'token' => Str::random(60),
            ]);
            if ($passwordReset) {
                ResetPasswordController::sendmailCustomer($passwordReset->token,$passwordReset->email);   ///+++
            }
            return response()->json([
            'message' => 'We have e-mailed your password reset link!'
            ]);
        }


            + Thay vì gọi hàm notify
                if ($passwordReset) {
                    $user->notify(new ResetPasswordRequest($passwordReset->token));
                }

            + Thì ta gọi hàm của ta :
                if ($passwordReset) {
                    ResetPasswordController::sendmailCustomer($passwordReset->token,$passwordReset->email);   
                }

        => QUÊN MẬT KHẨU CHO CUSTOMER ĐÃ XONG 



+ Ctrl + Lăn chuột để cỡ chữ trong Terminal nhỏ hơn . 
    C:\Users\LAPTOP KIM ANH\Downloads\SourceCodePBL4\API-Laravel>php artisan route:list




+ Download Collection Postman 
    + https://learning.postman.com/docs/getting-started/importing-and-exporting-data/


+ trong profile có gender nữa => thêm vào 
+ change for password laravel jwt 
+ tại trang đăng nhập của admin có quên mật khẩu . 
+ tất cả đều phải có 2 trường hợp là thực hiện thành công hay thất bại để return 200 hoặc 401 
    (Có một số cái chắc chắn thành công nếu có access_token) thì không có return thất bại 
    thường những cái có validator sẽ có return 422 , 401 

+ Customer có status : 0 thì không đăng nhập được nữa .  



+ CHÚ Ý : RESTful DELETE 
    + Một số phương thức không thể code tùy tiện được . 
    + Ví dụ Phương thức Delete (xóa một cái gì đó)

    + Ví dụ muốn xóa một admin . 
    + Nếu như làm ntn sẽ không được : 
        + api route : 
        Route::delete('delete-admin', 'deleteAdmin');// supper admin xóa account or supper admin

        + DELETE : http://127.0.0.1:8000/api/admin/delete-admin 
            {
                "rolelogin":"supper admin",
                "id":5
            }
        + 
        // Delete one Admin or Supper Admin 
        public function deleteAdmin(Request $request) {
            if($request->rolelogin == 'supper admin'){
                $user = User::find($request->id);
                $user->delete();
                return response()->json([
                    'message' => 'Delete admin successfully',
                ], 201);
            }
        } 
        => KHÔNG ĐƯỢC CODE THEO KIỂU NÀY . 


    + Phải là : 
        + Route::delete('{id}', 'deleteAdmin');// supper admin xóa account or supper admin 
        + DELETE : http://127.0.0.1:8000/api/admin/5
            {
                "rolelogin":"supper admin",
            }
        + 
            // Delete one Admin or Supper Admin 
            public function deleteAdmin(Request $request,$id) {
                if($request->rolelogin == 'supper admin'){
                    $user = User::find($id);
                    $user->delete();
                    return response()->json([
                        'message' => 'Delete admin successfully',
                    ], 201);
                }
            }


    + CHÚ Ý : NÊN CODE ROUTE API THEO KIỂU : 
        DELETE : /product/1  => xóa một sản phẩm cụ thể 
        PATCH  : /product/1  => cập nhật chi tiết 
        PUT    : /product/1  => thay thế toàn bộ cái củ bởi cái mới  
        GET    : /product/1  => lấy một sản phẩm cụ thể 
        POST   : /product    => tạo mới một sản phẩm 
        GET    : /product    => lấy toàn bộ sản phẩm 


+ Nói thêm : 
    + Tính đến chuyện account edit một số cái khác biệt như : role : admin thành supper admin 
    + Có khả năng bị hack bởi vì nếu như ta lấy role trực tiếp từ biến đã được lưu ở localStorage 
        => dù cho ta có v-if("role"=="supper admin") (chỉ hiện tính năng quản lý admin khi mà role là supper admin)
        => người dùng chỉnh admin thành supper admin và thế là xong . 

    + Cách khác phục những lỗi liên quan đến việc người dùng chỉnh sửa biến ở localStorage đó chính là 
    chỉ gửi lên email rồi từ đó where ra . 
        + Thông qua lớp bảo mật middleware thì chỉ có email và password đăng nhập vào mới có token đó 
        từ email where ra các thứ mình cần . Đó là biện pháp cải thiện bảo mật . 

    + Còn không quan tâm đến bảo mật và cho nhanh chóng thì gửi thẳng role lên cho server xử lý . 
    + Để bảo mật tốt thì có rất nhiều cách cải thiện .  

+ Để dùng được exception trong try catch 
    use Exception;

+ ĐÚNG RA KHI Supper Admin tạo tài khoản thì mật khẩu được random và gửi về email cho người dùng . 
    + Nhưng do là mình có ít tài khoản email nên không dùng được . Nhưng cái này thì nên code . Vì nhìn ok hơn .  

+ Vue (SPA) : Vue Single Page App . (Trang Ứng dụng Đơn)(Vue nằm trong Laravel)(dùng các file .blade.php và các file .vue)
+ https://topdev.vn/blog/xay-dung-vue-spa-single-page-app-voi-laravel-phan-1/


+ Change for password Laravel 8
    + Phải dùng hàm check password mới và củ của laravel 
    + Phải dùng hàm check password và comfirm password của laravel 
    + https://devnote.in/change-password-functionality-using-laravel-8/


+ return $this->respondWithToken($this->token);
+ $this ở đây chính là cái to nhất chính là : App\Http\Controllers\GoogleController
    thay vì mình : GoogleController::login() 
    thì $this->login() cũng được 


+ Hàm : 
    public function redirectToGoogle()
    {
        return Socialite::driver('google')->redirect();
    }
        
    /**
     * Create a new controller instance.
     *
     * @return void
     */
    public function handleGoogleCallback()
    {
        try {
      
            $user = Socialite::driver('google')->user();
       
            $finduser = Customer::where('google_id', $user->id)->first();
       
            if($finduser){
       
                Auth::login($finduser);
                // return redirect()->intended('dashboard');
                $this->token = auth()->guard('customer_api')->login($finduser);
                return response()->json([
                    'user' => $finduser,
                    'message'=>$this->respondWithToken($this->token)
                ]);
       
            }else{
                $newUser = Customer::create([
                    'fullname' => $user->name,
                    'email' => $user->email,
                    'google_id'=> $user->id,
                    'status'=>1
                    // 'password' => encrypt('123456dummy')
                ]);
      
                Auth::login($newUser);
                // return redirect()->intended('dashboard');
                $this->token = auth()->guard('customer_api')->login($newUser);
                return response()->json([
                    'user' => $newUser,
                    'message'=>$this->respondWithToken($this->token)
                ]);
            }
      
        } catch (Exception $e) {
            dd($e->getMessage());
        }
    }

    => Phải bỏ vào trong CustomerController.php mới được 







- OAuth2 Google Laravel
    + Đặt vấn đề : Như đã nói thì có 2 cách với OAuth2 
        + Cách 1 : Client Vuejs yêu cầu login google sau đó gửi toàn bộ thông tin và access_token lên server 
            + Code dài dòng => khó hiểu  
            + Vì code dài nên Khá là mệt vì xử lí nhiều cái 
            + Token lấy được từ client không được library JWT Auth trên server chấp nhận 
            + ĐẶC BIỆT : 
                + access_token không được chấp nhận mà chắc chắn bắt buộc là ta phải có một access_token nào đó 
                => lấy access_token từ server => nhưng để lấy được thì ta lại phải đăng nhập 
                => mà để đăng nhập thì phải có password => nếu ta tạo password cho email thì sẽ có vấn đề xảy ra 
                => giả sử ta đặt password là : pw_ + id_google => nếu người dùng đổi password => lần sau sẽ không đăng nhập được nữa 
            => Dễ thấy đây là một cách hoàn toàn không khả thi => rườm rà => và thực tế sẽ không ai code như này 


        + Cách 2 : OAuth2 bằng server Laravel 
            + Ý tưởng cách làm : 
                + Setup API Google cho server Laravel 
                + SetUp cho Server dùng được api đó để đăng nhập bằng google , cài các thư viện các kiểu 
                + Tại Client cho một link http://127.0.0.1:8000/auth/google trỏ đến một route '/auth/google' có trong file web.php của laravel 
                + Khi đến route này thì gọi hàm redirectToGoogle
                + Sau khi người dùng click vào chọn một tài khoản google thì chuyển đến trang 
                    'google' => [
                        'client_id' => '1079359168744-5c57ii2sljdgihdh7bmdrculb93q4qut.apps.googleusercontent.com',
                        'client_secret' => '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',
                        // 'redirect' => 'http://127.0.0.1:8000/api/customer/google/callback',
                        'redirect' => 'http://127.0.0.1:8000/auth/google/callback',  // trang này là trang được chuyển đến 
                    ],

                + Trong file web.php tiếp tục cho một route '/auth/google/callback' : nếu chuyển đến trang này 
                    thì gọi hàm handleGoogleCallback 
                        + Hàm này thực hiện xử lí 
                            + Nếu email chưa tồn tại thì là người mới => tạo tài khoản => đăng nhập 
                            + Nếu email đã tồn tại 
                                + Chưa có google_id thì cập nhật thêm google_id rồi cho đăng nhập 
                                + Có google_id thì là cho đăng nhập luôn 
                        
                        + ĐẶC BIỆT : Ta chỉ cần biến $provider là pass qua lớp đăng nhập và có được access_token mà không cần 
                            có password như ta hay đăng nhập bình thường . Cột password của tài khoản mới vẫn null . 

                + Sau khi qua hết ta có được token 
                + LÚC NÀY : 
                    + Ta có thể return response json bao gồm 
                        + Thông tin của người dùng đó 
                        + access_token 
                    + Tại trang http://127.0.0.1:8000/auth/google/callback nó dừng lại và hiển thị cho ta các thông tin đó dưới dạng json 
                    + LƯU Ý : Hai hàm redirectToGoogle và handleGoogleCallback phải bỏ vào CustomerController.php mới được 

                + VẤN ĐỀ : Chắc chắn không thể để như thế được : Không thể để người dùng dừng lại trang đó với các thông tin đó được . 
            
            + ĐIỀU CẦN LÀM : 
                + Ta phải chuyển về trang client (vuejs) của ta lại 
                + Lưu được thông tin người dùng mới đăng nhập 
                + Lưu được access_token 
                => Thật ra thứ QUAN TRỌNG CHÍNH LÀ ACCESS_TOKEN , vì nếu như có access_token ta có thể dùng nó để getProfile User 
                    và làm tất cả mọi thứ . 

            + CÁCH LÀM : 
                + Tại trang http://127.0.0.1:8000/auth/google/callback gọi đến hàm handleGoogleCallback ta không cho nó return nữa 
                    => từ chuỗi json đó ta chỉ cần lấy ra giá trị access_token : 
                        
                    $r = $this->respondWithToken($this->token)->getData()->access_token;

                + Sau đó return một file view và truyền token vào file view đó : 
                    return view('oauth2',['__r'=>$r]);

                + Trong file view => TA CŨNG KHÔNG THỂ DỪNG LẠI NGANG trang của file view oauth2.blade.php này được 
                + TA PHẢI CHUYỂN HƯỚNG VỀ CLIENT VUEJS của ta 
                    + oauth2.blade.php : code vào 
                        <body class="antialiased">
                            <input type="text" value="{{$__r}}" id="access_token" style="display: none;"> (1)
                            <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
                            <script>
                                $(document).ready(function(){
                                    var access_token = document.getElementById('access_token'); 
                                    window.location='http://localhost:8080/login?access_token='+access_token.value;
                                });
                            </script>
                        </body>


                    => Cho access_token vào input 
                    => Trong Javascipt lấy nó ra thông qua thẻ input sau đó dùng jquery (đã import) gọi hàm $(document).ready
                        => hàm này là khi đã đọc xong html (tức là đã có input và value chứa access_token) thì 
                        cho location chuyển hướng đến trang khác và mang theo token 

            + SAU KHI CHUYỂN HƯỚNG VỀ LẠI CLIENT VUEJS
                + Ta sẽ có link như thế này : 
                    http://localhost:8080/login?access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC8xMjcuMC4wLjE6ODAwMFwvYXV0aFwvZ29vZ2xlXC9jYWxsYmFjayIsImlhdCI6MTY2NDQ1ODYyNCwiZXhwIjoxNjY0NDYyMjI0LCJuYmYiOjE2NjQ0NTg2MjQsImp0aSI6IjRlY0JuenluVVFRem5qMXUiLCJzdWIiOjYsInBydiI6IjFkMGEwMjBhY2Y1YzRiNmM0OTc5ODlkZjFhYmYwZmJkNGU4YzhkNjMifQ.YE6nyMgzj2MTA-x2_sQfivM5bP4Jf10jASYPwJDp9vE 

                    + Trong hàm mounted() của vuejs 
                        => Ta sẽ lấy giá trị access_token rồi từ đó => LẤY TẤT CẢ NHỮNG GÌ MÌNH CẦN TỪ SERVER 


            + Tóm tắt lại đường đi 
                + http://localhost:8080/login 

                => click vào link <a href="127.0.0.1:8000/auth/google">Login By Google</a> 
                
                => redirectToGoogle => redirect' => 'http://127.0.0.1:8000/auth/google/callback' => handleGoogleCallback
                
                => $r = $this->respondWithToken($this->token)->getData()->access_token; => return view('oauth2',['__r'=>$r]);
                
                => /views/oauth2.blade.php : window.location='http://localhost:8080/login?access_token='+access_token.value;
                
                => http://localhost:8080/login?access_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC8xMjcuMC4wLjE6ODAwMFwvYXV0aFwvZ29vZ2xlXC9jYWxsYmFjayIsImlhdCI6MTY2NDQ1ODYyNCwiZXhwIjoxNjY0NDYyMjI0LCJuYmYiOjE2NjQ0NTg2MjQsImp0aSI6IjRlY0JuenluVVFRem5qMXUiLCJzdWIiOjYsInBydiI6IjFkMGEwMjBhY2Y1YzRiNmM0OTc5ODlkZjFhYmYwZmJkNGU4YzhkNjMifQ.YE6nyMgzj2MTA-x2_sQfivM5bP4Jf10jASYPwJDp9vE 

                => vuejs mouted() => có access_token => server . 
                (Đến đoạn này có thể lấy xong set lại location cho nó là : http://localhost:8080/login cũng được còn không thì để nguyên như thế)

            + NHẬN XÉT : 
                + Với cách này : Có thể áp dụng cho đăng nhập Facebook cho người dùng và nhiều thứ khác có trong : 
                
                https://socialiteproviders.com/about/#provider-issues

                Social / Platform : 
                    Apple, Authentik, Auth0, Cognito, Dailymotion, Deviantart, Dribbble, Facebook, Flattr, Flickr, Foursquare, 
                    FusionAuth, Gitea, GitHub, GitLab, Google, Imgur, Instagram, Instagram Basic, Kakao, Keycloak, LaravelPassport, Line, Medium, Meetup, Microsoft, Microsoft Azure, Naver, OAuthgen, Odnoklassniki, Okta, Pinterest, Pixnet, Planning Center, Pushbullet, QQ, Reddit, Snapchat, StackExchange, Steem, SURFconext, Telegram, TikTok, Tumblr, Twitter, Vimeo, VK, WeChat Service Account, WeChat Web, Weibo, Weixin, Weixin Web, WordPress, Yahoo, Yammer, Yandex, YouTube, Zalo

                Gaming : 
                    Battlenet, Discord, Eveonline, Lichess, Minecraft, ProjectV, Smashcast, Steam, StreamElements, Streamlabs, Twitch

                Education / Career : 
                    Acclaim, Coursera, Dataporten, AppNet, Goodreads, HeadHunter, MoiKrug, SciStarter, StockTwits, Xing

                Productivity / Business :
                    Asana, 37Signals, Atlassian, Aweber, Bitly, Bitbucket, Bitrix24, Box, Buffer, CampaignMonitor, Cheddar, ConstantContact, DigitalOcean, Disqus, Dropbox, Envato, Etsy, Eventbrite, EyeEm, GettyImages, Gitee, Harvest, Heroku, HubSpot, Human API, Intercom, LinkedIn, MailChimp, Mailru, MakerLog, Mattermost, MercadoLibre, Monday, Netlify, Notion, OSChina, OVH, Pipedrive, Podio, Procore, ProductHunt, QuickBooks, Readability, Sage, SalesForce, SharePoint, Shopify, SuperOffice, Teamleader, Teamweek, Todoist, Trello, Unsplash, Vercel, VersionOne, Webex, WHMCS, Zendesk, Zoho, Zoom

                Government / University : 
                    ClaveUnica, FranceConnect, IFSP, UCL

                Payments : 
                    Binance, Coinbase, Gumroad, MediaCube, Mollie, Monzo, Patreon, Paymill, PayPal, PayPalSandbox, Redbooth, Starling, Stripe, Venmo, Xero

                Music : 
                    Deezer, Discogs, Mixcloud, SoundCloud, Spotify

                Misc : 
                    Admitad, AngelList, ArcGIS, Douban, Fablabs, Fitbit, Flexkids, GarminConnect, PeeringDB, RunKeeper, Saml2, Strava, Trakt, TVShowTime, Uber, Untappd, Withings

        + CHÚ Ý SAU NÀY KHI Deploy thì thay đổi các giá trị ví dụ như trong file service.php hay .env các kiểu 


- OAuth2 Facebook Laravel (Tương tự)
    + Vào Facebook Developers để tạo api ta được :   
        https://developers.facebook.com/apps/464118715744858/settings/basic/

    + ID ứng dụng : 464118715744858
    + Khóa bí mật của ứng dụng : 38de2df7d427d3392375b21384ed8b9b

    + > composer require socialiteproviders/facebook
    + config/services.php
        'facebook' => [
            'client_id' => '464118715744858',
            'client_secret' => '38de2df7d427d3392375b21384ed8b9b',
            'redirect' => 'http://127.0.0.1:8000/auth/facebook/callback',
        ],

    + Migrate 
        Schema::create('customers', function (Blueprint $table) {
            $table->id();
            $table->string('fullname');
            $table->string('email')->unique();
            $table->string('username')->unique()->nullable();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password')->nullable();
            $table->string('address')->nullable();
            $table->date('date_of_birth')->nullable();
            $table->boolean('gender')->nullable();
            $table->boolean('status')->nullable();
            $table->string('phone')->nullable();
            $table->string('google_id')->nullable();
            $table->string('facebook_id')->nullable();   ///+++ 
            $table->rememberToken();
            $table->timestamps();
        });

    + Model 
        class Customer extends Authenticatable implements JWTSubject
        {
            use HasFactory;

            protected $fillable = [
                'fullname',
                'email',
                'username',
                'password',
                'address',
                'date_of_birth',
                'gender',
                'phone',
                'url_img',
                'status',
                'google_id',
                'facebook_id'  ///+++ 
            ];

    + web.php 
        Route::get('auth/facebook', [CustomerAuthController::class, 'redirectToFacebook']);
        Route::get('auth/facebook/callback', [CustomerAuthController::class, 'handleFacebookCallback']);

    + CustomerAuthController.php 

        public function redirectToFacebook()
        {
            return Socialite::driver('facebook')->redirect();
        }

        public function handleFacebookCallback()
        {
            try {
          
                $user = Socialite::driver('facebook')->user();
           
                $finduser = Customer::where('facebook_id', $user->id)->first();
                $email = $user->email;

                if($finduser){
           
                    Auth::login($finduser);
                    $this->token = auth()->guard('customer_api')->login($finduser);

                    $r = $this->respondWithToken($this->token)->getData()->access_token;
                    return view('oauth2',['__r'=>$r]);
           
                }else{
                    $sysUser = Customer::where('email',$email)->first();
                    if($sysUser){
                        $sysUser->update(['facebook_id' => $user->id]);
                        Auth::login($sysUser);
                        $this->token = auth()->guard('customer_api')->login($sysUser);

                        $r = $this->respondWithToken($this->token)->getData()->access_token;
                        return view('oauth2',['__r'=>$r]);
                    }
                    else {
                        $newUser = Customer::create([
                            'fullname' => $user->name,
                            'email' => $user->email,
                            'facebook_id'=> $user->id,
                            'username'=> 'fb_'.$user->id,
                            'status'=>1
                            // 'password' => encrypt('pw_')
                        ]);

                        Auth::login($newUser);
                        $this->token = auth()->guard('customer_api')->login($newUser);

                        $r = $this->respondWithToken($this->token)->getData()->access_token;
                        return view('oauth2',['__r'=>$r]);
                    }
                }
          
            } catch (Exception $e) {
                dd($e->getMessage());
            }
        }


    + Kiểm tra nếu có facebook_id rồi thì cho đăng nhập luôn 
    + Nếu chưa có mà chưa có email rồi (email có rồi này có thể là tự tạo hoặc của google login cũng được hết)
    + Nếu chưa có thì tạo mới tài khoản (chỗ này cần xử lí thêm ở trường email vì nhỡ người dùng đăng nhập bằng số điện thoại)
    => XONG 


+ Tạo Id Client Twitter : 
    https://developer.twitter.com/en/apps




+ Đổi mật khẩu cho User và Admin 
    + https://devnote.in/change-password-functionality-using-laravel-8/
    + Tất nhiên là phải đăng nhập đã mới đổi được 
    + Ở đây có một điều hay là => tương ứng với mỗi access_token gửi vào và gọi hàm này Auth::user() 
        thì nó tự động hiểu là tài khoản cụ thể nào đang đăng nhập vào 
        (mà không cần phải gửi lên id hay email để find($id) hay where('email',$email) )

        => gửi access_token lên và $user = Auth::user() là coi như ta đã có tài khoản đó và sau đó làm gì cũng được . 
        Hoặc là ta có thể dùng trực tiếp Auth::user() cũng được . 

    + User (Customer) và Admin | Supper Admin (User) hàm đổi password tương tự nhau chỉ đổi Model để thay đổi dữ liệu của trường password thôi 

    + Change Password for Admin (User)

        public function changePassword(Request $request) {

            $user = User::find($request->id);
            // mật khẩu trong database và mật khẩu nhập vào phải giống nhau 
            if (!(Hash::check($request->get('current_password'), $user->password))) {
                return response()->json([
                    'message' => 'Your current password does not matches with the password.',
                ],400);
            }

            if(strcmp($request->get('current_password'), $request->get('new_password')) == 0){
                return response()->json([
                    'message' => 'New Password cannot be same as your current password. ',
                    // mật khẩu mới không được giống với mật khẩu hiện tại (mật khẩu cũ)
                ],400);
            }

            // mật khẩu mới và confirm phải giống nhau 
            if($request->get('new_password') != $request->get('new_password_confirmation')){
                return response()->json([
                    'message' => 'Your new password does not matches with the new password confirm.',
                ],400);
            }

            $validator = Validator::make($request->all(), [
                'current_password' => 'required',
                'new_password' => 'required|string|min:6',
            ]);
            if($validator->fails()){
                return response()->json($validator->errors(), 400);
            }

            //Change Password
            $user->update(['password' => bcrypt($request->get('new_password'))]);
            return response()->json([
                'message' => "Password successfully changed !",
            ],200);
        }
        


+ Cách để trả về một mảng các lỗi :  

    return response()->json([
        'email' => ['Email already exists'],
    ],401);

    + Để cho phù hợp với cái này nếu không nó sẽ tách các chữ cái của message ra rồi hiện ra lỗi là từng chữ cái 
        (Bởi vì không phải một mảng)
            .catch(error=>{
                console.log(error);
                this.err = error.response.data;
                var error2 = this.err;

                if(error2.fullname) this.inError(error2.fullname);
                if(error2.username) this.inError(error2.username);
                if(error2.email) this.inError(error2.email);
                if(error2.address) this.inError(error2.address);
                if(error2.phone) this.inError(error2.phone);
                if(error2.age) this.inError(error2.age);
                // this.err = error.reponse.status;
            })
        },
        inError:function(er){
            const { emitEvent } = useEventBus();
            for(var i=0;i<er.length;i++) emitEvent('eventError',er[i]);
        }
    }

    <!--  -->


+ <input type="date" format="YYYY MM DD" >

+ Token sau một thời gian sẽ hết hạn vì thế nếu có lỗi 401 => bắt lỗi này trong file RESTful 
    sau đó cho nó xóa biến user hoặc admin để đăng xuất nó . 


+ Thanh scroll bar khi ẩn khi hiện thế , lần đầu hiện một lúc , sau thì nó ẩn 
+ https://getbootstrap.com/docs/4.3/components/popovers/

+ Sau một thời gian thì token hết hiệu lực hoặc nếu như người dùng cố gắng hack bằng cách 
    thêm biến admin :{} vào localSotage thì cũng vô ích vì nếu như token sau thì sẽ trả về lỗi 401 và cho về lại trang login 
    Ta không lo lưu biến admin tại localStorage vì mỗi lần RESTful đều có yêu cầu accesss_token 
    nếu token sai thì không làm được gì cả chính vì thế chắc chắn phải đăng nhập mới làm được 
    => Test thử bằng cách không đăng nhập rồi tự thêm biến admin vào localaStorage sau đó làm một cái gì đó 
    cần middleware (cần access_token) thì sẽ bị bật lỗi ra và về lại trang loggin 


+ Thêm bảng đồ vào project (google map js)

+ Ta có thể đổi role thành 'admin' rồi sau đó mới xóa được 
    => Nhưng cũng chẳng có nghĩa gì cả gì tất cả thao tác đó đều dưới quyền của super admin 
    vì vậy thay vì đổi một account từ super admin thành admin xong mới xóa 
    thì xóa luôn cho khỏe 

+ Ta nên để code html không liên quan ngoài v-for càng nhiều càng tốt vì khi v-for nó sẽ v-for ra nhiều làm cho trang web ta chạy 
chậm 
    + Ví dụ như khi Delete => trong v-for mới nhận được các giá trị mình cần là : id 
    => lưu id cần xóa này vào biến trong data return 

    + Cho Model ở ngoài v-for => khi click nút xóa trong v-for thì gọi model lên một lần nữa để xem super admin chắc chắn muốn xóa không . Nếu có nhấn Delete thì lúc này gọi hàm Delete và dùng id lưu từ trước và xóa . 

    + Có các sự kiện xảy ra như sau 
        + Click vào nút Delete => lấy id gán cho idDelete 
        + Click vào close thì cho idDelete = null 
        + Model hiện ra => click vào delete thì xóa luôn và cho close.click() tự click 
        trong cái tự click này nó đã cho idDelete = null như đã nói ở trên . 
        Còn không nữa thì cho idDelete = null ngay trong hàm delete 

        + Có một sự kiện đó và click ra ngoài vùng là nó tự ẩn model => idDelete vẫn còn lưu nhưng vẫn chưa xử lí gì 
        => không lo vì Model chỉ hiện ra khi mà click một nút delete nào đó 
        mà khi đã click nút delete nào đó mới thì id tự lấy giá trị mới thôi 
        + Thậm chí ta không cần set null idDelete luôn cũng được vì mỗi lần click mới là nó đã gán giá trị mới rồi  


+ Chú ý : Uncaught TypeError: Cannot read properties of undefined (reading 'deep') when upgrade to vue 3.x
    + Chỉ là lỗi chính tả do mình gõ sai : v-model thành v-mode 
        <input type="text" class="form-control" v-moel="newUser.name">
        after I fixed the typo v-moel to v-model, it got fixed
    + Và trên stack overflow cũng có => chứng tỏ lần sau cái gì fix không được thì tra google cho nhanh   
    => Cái này nhắt đi nhắt lại nhiều rồi . Những thứ mình bị bug là có nhiều người gặp qua rồi . 


+ Cân nhắt việc đổi mật khẩu cũng làm giống như đăng kí tài khoản 
    => ẩn model luôn rồi hiện lỗi 
    => vào lại vẫn còn các giá trị 
    => đổi password thành công thì mới reset hoặc có thể reset các trường input luôn cũng được không sao cả .

+ Giao diện quên mật khẩu cho admin 
+ thanh navigate 
+ search , watch()
    + q viết tắt của query 
    + hoặc có thể là dùng biến search 
+ block user 

+ gửi password random về email người dùng


+ CHÚ Ý : 
    + fresh(): Tải lại dữ liệu từ database và trả về một đối tượng mới.      (cập nhật lại các bảng và không reset dữ liệu)
    + refresh(): Tải lại dữ liệu từ database và cập nhật lại đối tượng gốc.  (reset lại toàn bộ dữ liệu) 

    https://laravel.com/docs/9.x/eloquent?fbclid
    https://github.com/laravel/framework/blob/9.x/src/Illuminate/Database/Eloquent/Model.php
    https://laravel-code.tips/understand-the-difference-between-fresh-and-refresh-one-returns-a-fresh-new-instance-while-the-other-refreshes-an-existing-instance/?fbclid=IwAR0_yCtC-QoiwbstMsuVtSNFSnYTTXp2ZJOUDLMT6Jq_14fF_CQGKWvcFaE


+ Balde trênn github là : những file trong folder views ví dụ : welcome.blade.php 
+ cân nhắt đổi user_order thành customer_order cho dúng  



+ paginate(số lượng) phân trang (hay) trong Laravel (đọc kĩ ở document)

    + Đặt vấn đề : Nếu mỗi trang chỉ load ra 5 admin mỗi trang mà phải lấy rất cả database của bảng admin xuống 
    sau đó v-for ra => sẽ nặng cho trang của mình . Thay vì như thế chỉ lấy ra đúng 5 admin rồi v-for ra 5 cái đó .
        + Mình sẽ lấy ra biến number là số admin có trong database ví dụ có 17 admin 
        => Mỗi trang 5 admin => có 4 trang 

        // Đây là code lấy tất cả admin => ta sẽ đổi lại để chỉ lấy 5 admin 
        public function allAdmins(Request $request) {
            if($request->rolelogin == 'super admin'){
                $users = User::where('id','!=',$request->idlogin)->get(); // lấy tất cả ngoại trừ cái đứa đăng nhập 
                return response()->json([
                    'message' => 'Get all admins information successfully !',
                    'user' => $users
                ], 201);
            }
            return response()->json([
                'message' => 'Get all admins fails !',
            ], 400);
        }

    + ->paginate() trong laravel rất là hay => nó hỗ trợ nhiều cái 
        + ->paginate(5 Phải để cuối (nó giống như cái get vậy) 


        public function allAdmins(Request $request) {
            $n = count(User::all())-1; // trừ đi đứa đang đăng nhập 
            if($request->rolelogin == 'super admin'){
                $users = User::where('id','!=',$request->idlogin)->paginate(5); // lấy ra 5 đứa ngoại trừ cái đứa đăng nhập 
                return response()->json([
                    'quantity' => $n,
                    'message' => 'Get all admins information successfully !',
                    'user' => $users
                ], 201);
            }
            return response()->json([
                'message' => 'Get all admins fails !',
            ], 400);
        }

        GET: http://127.0.0.1:8000/api/admin/all-admin?page=1
            {
                "rolelogin":"super admin",
                "idlogin":1,
            } 

        JSON : 
        {
            "quantity": 9,
            "message": "Get all admins information successfully !",
            "user": {
                "current_page": 1,
                "data": [
                    {
                        "id": 2,
                        "fullname": "Nguyễn Công Cường",
                        "email": "congcuong222@gmail.com",
                        "username": "congcuong222",
                        "email_verified_at": null,
                        "address": "Tam Ky - Quang Nam - Viet Nam",
                        "date_of_birth": "2022-09-06",
                        "gender": 1,
                        "phone": "0123456789",
                        "url_img": "storage/images/T2fPnOwVPWVyWmPuQ8X2OuYoKEN47nq0gHnXo5yH.jpg",
                        "role": "super admin",
                        "created_at": "2022-09-28T05:28:01.000000Z",
                        "updated_at": "2022-09-30T18:00:26.000000Z"
                    },
                    {
                        "id": 6,
                        "fullname": "Nguyễn Thị Mỹ An",
                        "email": "myandethuong@gmail.com",
                        "username": null,
                        "email_verified_at": null,
                        "address": null,
                        "date_of_birth": null,
                        "gender": null,
                        "phone": null,
                        "url_img": null,
                        "role": "super admin",
                        "created_at": "2022-09-30T19:01:15.000000Z",
                        "updated_at": "2022-09-30T19:09:19.000000Z"
                    },
                    {
                        "id": 7,
                        "fullname": "Trần Thị Thùy Dương",
                        "email": "thuyduongcute@gmail.com",
                        "username": null,
                        "email_verified_at": null,
                        "address": null,
                        "date_of_birth": null,
                        "gender": null,
                        "phone": null,
                        "url_img": null,
                        "role": "admin",
                        "created_at": "2022-09-30T19:08:57.000000Z",
                        "updated_at": "2022-09-30T19:09:28.000000Z"
                    },
                    {
                        "id": 8,
                        "fullname": "ascasacas",
                        "email": "vanmanascsacasch111@gmail.com",
                        "username": null,
                        "email_verified_at": null,
                        "address": null,
                        "date_of_birth": null,
                        "gender": null,
                        "phone": null,
                        "url_img": null,
                        "role": "super admin",
                        "created_at": "2022-10-01T06:04:10.000000Z",
                        "updated_at": "2022-10-01T06:04:10.000000Z"
                    },
                    {
                        "id": 9,
                        "fullname": "saccscsacascs",
                        "email": "vanascascsacmanh111@gmail.com",
                        "username": null,
                        "email_verified_at": null,
                        "address": null,
                        "date_of_birth": null,
                        "gender": null,
                        "phone": null,
                        "url_img": null,
                        "role": "admin",
                        "created_at": "2022-10-01T06:04:23.000000Z",
                        "updated_at": "2022-10-01T06:04:23.000000Z"
                    }
                ],
                "first_page_url": "http://127.0.0.1:8000/api/admin/all-admin?page=1",
                "from": 1,
                "last_page": 2,
                "last_page_url": "http://127.0.0.1:8000/api/admin/all-admin?page=2",
                "links": [
                    {
                        "url": null,
                        "label": "&laquo; Previous",
                        "active": false
                    },
                    {
                        "url": "http://127.0.0.1:8000/api/admin/all-admin?page=1",
                        "label": "1",
                        "active": true
                    },
                    {
                        "url": "http://127.0.0.1:8000/api/admin/all-admin?page=2",
                        "label": "2",
                        "active": false
                    },
                    {
                        "url": "http://127.0.0.1:8000/api/admin/all-admin?page=2",
                        "label": "Next &raquo;",
                        "active": false
                    }
                ],
                "next_page_url": "http://127.0.0.1:8000/api/admin/all-admin?page=2",
                "path": "http://127.0.0.1:8000/api/admin/all-admin",
                "per_page": 5,
                "prev_page_url": null,
                "to": 5,
                "total": 8
            }
        }


    + TA THẤY : 
        + ĐIỀU ĐẶT BIỆT LÀ biến page => trong Laravel tự nhận diện biến đó cho ta , ví dụ ta có 17 đứa admin 
            + paginate(5) mà ?page=1 => trả về bảng ngoại trừ thằng đang đăng nhập => lấy ra 5 đứa đầu tiên 
            + paginate(5) mà ?page=2 => trả về đứa thứ 6 đến đứa thứ 10 
            + paginate(5) mà ?page=4 => trả về đứa thứ 16 đến 17 (vì trong database ta chỉ có 17 đứa)

        + Thay vì 
            GET : http://127.0.0.1:8000/api/admin/all-admin?page=2 
            {
                "rolelogin":"super admin",
                "idlogin":1,
            }

        + Thì 
            GET : http://127.0.0.1:8000/api/admin/all-admin
            {
                "rolelogin":"super admin",
                "idlogin":1,
                "page":2
            }

            => cũng được 

        + Ngoài những thông tin cần thiết như tổng số admin đang có , 5 admin tương ứng với mỗi page 
        thì laravel còn trả về cho ta các dữ liệu khác và có thể dùng nó nếu cần 


+ Xóa rồi nhưng vào vẫn còn là do cập nhật chậm chứ không phải lỗi 
    => xóa mà thông báo xóa thành công là ok . 

            <paginate class="pag" id="nvm"
                :page-count="Math.ceil(this.quantity/5)"
                :page-range="3"
                :margin-pages="2"
                :click-handler="clickCallback"
                :initial-page="1"   đây là trang mặc định khi mới khở tạo 
                :prev-text="'Prev'"
                :next-text="'Next'"
                :container-class="'pagination'"
                :page-class="'page-item'">
            </paginate>

            clickCallback:function(pageNum){
                BaseRequest.get('api/admin/all-admin?idlogin='+this.admin.id+'&rolelogin='+this.admin.role+'&page='+pageNum)
                .then( (data) =>{
                    // console.log(data);
                    this.quantity = data.quantity;
                    this.pageN = pageNum;
                    // let urlParams = new URLSearchParams(window.location.search);
                    // urlParams.set('page', this.pageN);
                    // window.location.search.set('page',this.pageN);
                    this.admins = data.user.data ;
                    const { emitEvent } = useEventBus();
                    emitEvent('eventSuccess','Get All Admin Success !');

                    // setTimeout(()=>{
                    //     window.location=window.location.href;
                    // }, 1500);
                }) 
                .catch(error=>{
                    console.log(error);
                    const { emitEvent } = useEventBus();
                    emitEvent('eventError',error.response.data.message);

                    // Nếu là admin thì không vào được quản trị và không get được thì cho về trang chủ 
                    setTimeout(()=>{
                        this.$router.push({name:'DashboardAdmin'}); 
                    }, 1500);
                })
            },




+ Một số lệnh query dùng mysql query sẽ ok hơn eloquent thì dùng : DB:select 
    + Chỉ cần bỏ nguyên câu lệnh vào là được :  
    + tham khảo : https://viblo.asia/p/mot-so-cach-su-dung-raw-db-query-trong-laravel-3P0lPq145ox
    + Convert Mysql to Eloquent : https://jjlabajo.github.io/SQLtoEloquent/



+ Trong Laravel query tiếng việt nó cũng tìm ra được không dấu 
    ví dụ : search : Mạnh thì username : nguyenvanmanh nó cũng ra vì trong "nguyenvanmanh" có "manh"



+ Function in Eloquent Laravel 
+ Trong Eloquent Laravel => Chức năng của function như là dấu ngoặc để biết thực hiện lệnh nào trước , lệnh nào sau 
    và and or các kiểu . 
    + Key word : Fuction in Eloquent Laravel . 
    + Tham khảo : https://stackoverflow.com/questions/42825554/how-can-i-add-brackets-on-the-laravel-eloquent-laravel-5-3
                  https://laravel.com/docs/9.x/eloquent
                  https://viblo.asia/p/cac-function-huu-dung-khi-lam-viec-voi-eloquent-laravel-Qpmle21r5rd



        Ví dụ : SELECT * FROM message WHERE (seller_id = 1 OR buyer_id = 3) AND deleted_by NOT LIKE '%1%'

        Sẽ thành : 

            Message::where(function($query){
                $query->where('buyer_id', auth()->user()->id)
                ->orWhere('buyer_id', auth()->user()->id);
            })
            ->where('deleted_by', 'not like', '%'.auth()->user()->id.'%')
            ->get();


    + phép AND của mysql được xem như là mặc định rồi
        ví dụ : id = 2 AND name = 'Manh' thì eloquent là : ::where('id',3)->where('name','Manh')
    + Còn OR thì là orWhere 




+ Tìm kiếm real time Vuejs API Laravel 

+ Có 3 hàm chính 
    + mounted() 
    + click call back ()
    + search 



    + Hàm trong API : 

        public function allAdmins(Request $request) {
            if($request->rolelogin == 'super admin'){
                $search = $request->search;

                $users = User::where(function($query) use($search) {
                        $query->where('date_of_birth','LIKE', '%'.$search.'%')
                        ->orWhere('phone','LIKE', '%'.$search.'%')
                        ->orWhere('role','LIKE', '%'.$search.'%')
                        ->orWhere('gender','LIKE', '%'.$search.'%')
                        ->orWhere('username','LIKE', '%'.$search.'%')
                        ->orWhere('email','LIKE', '%'.$search.'%')
                        ->orWhere('fullname','LIKE', '%'.$search.'%');
                    })->where('id','!=', $userId)->paginate(5);
                
                $users2 = User::where(function($query) use($search) { 
                            $query->where('date_of_birth','LIKE', '%'.$search.'%')
                            ->orWhere('phone','LIKE', '%'.$search.'%')
                            ->orWhere('role','LIKE', '%'.$search.'%')
                            ->orWhere('gender','LIKE', '%'.$search.'%')
                            ->orWhere('username','LIKE', '%'.$search.'%')
                            ->orWhere('fullname','LIKE', '%'.$search.'%')
                            ->orWhere('email','LIKE', '%'.$search.'%');
                        })->where('id','!=', $userId)->get();
                $n = count($users2); // lấy ra và search và trừ đi đứa đang đăng nhập 
                $n là đếm xem có tất cả bao nhiêu dòng thõa mãn 

                return response()->json([
                    'quantity' => $n,
                    'message' => 'Get all admins information successfully !',
                    'user' => $users
                ], 201);
            }
            return response()->json([
                'message' => 'Get all admins fails !',
            ], 400);
        }


        use($search) => biến được truyền vào function , nếu có nhiều biến thì ví dụ use($search,$id,$name) 


+ Trong một input 
    + alt là làm sạch input 
    + khi đang nhập tiếng việt thì nhấn một nút bất kì như enter hoặc ctrl thì nó cũng tìm kiếm vì mình watch rồi 
        (không cần cách ra)  

+ Đang tìm kiếm mà thêm một người thì thêm xong nó tải lại link thì cx để như thế (hiện trạng vẫn đang tìm kiếm)
    không nên reset lại ô input => đó là một tính năng 
    và chỉ khi click vào Administrator mới reset lại . 

    + ví dụ đang tìm 'Trần' mà thêm một người có họ 'Trần' thì nó cũng tiếp tục hiện ra thêm người đó 



+ CHÚ Ý PHẦN GỬI MAIL : 
    + Mỗi file Mail chỉ được gọi đến một file .blade.php 
    + Ví dụ trước đó ta có file Mail/NotifyMail => gọi đến return $this->view('emails.contentMail',['__url' => $url]);
        file emails/contentMail.blade.php

    + >php artisan make:mail SendPassword
        <?php

        namespace App\Mail;

        use Illuminate\Bus\Queueable;
        use Illuminate\Contracts\Queue\ShouldQueue;
        use Illuminate\Mail\Mailable;
        use Illuminate\Queue\SerializesModels;

        class SendPassword extends Mailable
        {
            use Queueable, SerializesModels;

            /**
             * Create a new message instance.
             *
             * @return void
             */
            public $password;
            public function __construct($_password)
            {
                //
                $this->password = $_password;

            }

            /**
             * Build the message.
             *
             * @return $this
             */
            public function build()
            {
                return $this->view('emails.sendpassword',['__pw' => $this->password]);  /////+++ 
            }
        }

        => Gọi đến emails/sendpassword.blade.php 
        (chú ý không nhất thiết là phải ở trong folder emails)(cái này tùy ý sao cũng được)

    + Cho gửi Mail trong Controller 
        public function register(Request $request){

        if($request->rolelogin == 'super admin'){
            $password = Str::random(8);
            $validator = Validator::make($request->all(), [
                'fullname' => 'required|string|between:2,100',
                'email' => 'required|string|email|max:100|unique:users',
                // 'password' => 'required|string|min:6',
                'role' => 'required|in:admin,super admin',
            ]);
    
            if($validator->fails()){
                return response()->json($validator->errors(), 400);
            }
    
            $user = User::create(array_merge(
                $validator->validated(),
                // ['password' => bcrypt($request->password)]
                ['password' => bcrypt($password)]
            ));

            Mail::to($request->email)->send(new SendPassword($password)); 
            // Mail không tồn tại nó cũng không báo lỗi , chỉ là nó không gửi password đến thôi 
            // 2 dòng dưới này là bắt sự kiện gửi mail được hay không . 
            // if (Mail::failures()) return response()->json(["message"=>"Sorry! Please try again latter"],400);
            // else return response()->json(["message"=>"Great! Successfully send in your mail"],200);
            // Mail không tồn tại mà không báo lỗi thì càng tốt . Một mặt khi test ta có thể đăng kí thoải mái 
            // Mặt khác email đó không tồn tại => tất nhiên ta sẽ không có password để đăng nhập 
            // về mặt thực tế nếu Nhân viên cung cấp email sai thì cũng không có tài khoản để sử dụng . 
            
            // Trường hợp forgot password cũng tương tự . 
            // Chỉ khi email không tồn tại trong hệ thống mới báo lỗi còn email có trong hệ thống nhưng trên thực tế 
            // không tồn tại thì cũng không báo lỗi khi gửi token đi để xác thực mật khẩu . 

            return response()->json([
                'message' => 'User successfully registered',
                'user' => $user
            ], 201);
        }
        return response()->json([
            'message' => 'User failse registered !',
        ],400);
    }



+ Vì ta không thể đăng nhập các tài khoản có email trên thực tế không tồn tại được 
    => không chỉnh sửa thông tin được => để chỉnh sửa thông tin sau này hiện ra cho đẹp
    => vào trực tiếp database để chỉnh sửa 
    => về ảnh thì lấy ảnh và copy paste vào cả 2 folder storage và public của laravel 
    rồi cho tên file vào database 

    => Nên đặt tên file ngắn vì sẽ khó trùng với các file có tên dài được hash ra được push lên bởi api của laravel 


+ 405 : Lỗi sai phương thức 

+ Reset password có một lỗi đó là : 
    + Nếu email được nhập vào không có trong hệ thống => không lỗi => không sinh ra token 
    + Nếu email có trong hệ thống thì : 
        + Giả sử có 2 người seset 
        + Người 1 gửi yêu cầu => token 1 được sinh ra và lưu trong table password reset 
        + Người 1 chưa reset lại password (nên token 1 và email tương ứng của người 1 vẫn còn trong database)
        + Người 2 reset => token 2 được sinh ra và THAY THẾ LUÔN CHO token của người 1  
        => dẫn đến khi người 1 vào lại xác thực => khác token => không được . 


    + Và có một điều là : Chỉ cần một người đổi mật khẩu thành công => toàn bộ token trong database sẽ bị xóa . 

        + Đoạn code của laravel 
            $passwordReset = PasswordReset::updateOrCreate([
                'email' => $user->email,
            ], [
                'token' => Str::random(60),
            ]);


        + Đây là hai đoạn code với chức năng giống nhau . Đoạn dưới này mình tự code nhưng nó cũng không thay đổi gì cả 
        nó cũng giống như cũ với đoạn code của laravel nên mình để lại như cũ . 
            $token = Str::random(60);
            $passwordReset = PasswordReset::where('email',$user->email)->first();
            if($passwordReset) $passwordReset->update(['token' => $token]);
            else $passwordReset = PasswordReset::create(['email' => $user->email,'token' => $token]);


+ Khi lưu tài khoản vào google chrome 
    => Khi đổi mật khẩu => gg tự điền vào ô input : curren_password cho ta luôn 
    => còn 2 ô mới thì ta tự điền 


+ SẢN PHẨM , ADMIN , CUSTOMER mới thì lên đầu dòng 
    => Khi lấy ra thì đảo mảng lại . 

+ Tiêu đề của các trang (document.title)
+ Có một tính năng hay nữa đó là : 
    + Ghi kéo kết thanh cuộn ở menu nav bar rồi thì nó sẽ chuyển sang kéo phần view-content ở bên này . 


+ Trong database . Mình lưu customer 1 nghĩa là không bị block . 0 Nghĩa là bị block . 
    + trong vue <input type="checkbox" :checked="0"> 
        + Như thế này là không được tick 
    + trong vue <input type="checkbox" :checked="1"> 
        + Như thế này là được tick 

    + Nhưng trong stype cái button-6 mà mình chọn thì ngược lại nên mình dùng là : 
        <input :checked="!cus.status" type="checkbox" class="checkbox" />

    => Nói chung thì vẫn là thế chỉ là cách hiển thị khác thôi không có gì cả 
        + trong database nếu 1 thì nó hiện là YES , 0 thì nó hiện là NO 

+ Những phần mền ghi và lưu liên tục (không cần nhất save) : chỉ cần watch biến text đó . 
    + Thay đổi chừng nào thì thực hiện lệnh lưu chừng đó . (Một lệnh gọi đến server để lưu dữ liệu được gọi đi , gọi lại nhiều lần)
     


===========Cần Làm===========
    + Thêm nút Mới nhất và Cũ nhất tại bảng User và Admin , Category , Product ,... 


+ trong một thẻ ví dụ thẻ div ngay trên html ta thêm thẻ style gõ vài từ đầu tiên style mà ta muốn có
    sau đó NHẤN ctrl + dấu cách => nó sẽ hiện lên ĐẦY ĐỦ style đó . (không cần phải đợi)
    => khá là ok   
    => áp dung cho cả phần style ở phía dưới nếu vscode load style chậm quá thì ta nhấn tổ hợp phím đó 
    (hoặc thậm chí không gõ cũng được)

+ Nhiều style hay 
    + https://getcssscan.com/css-box-shadow-examples


+ @click="resetpage($event)"> : truyền vào một sự kiện 



- where - join - orderBy - function in eloquent laravel 
+ Try this solution.
$mainModelData = mainModel::where('column', $value)
    ->join('relationModal', 'main_table_name.relation_table_column', '=', 'relation_table.id')
    ->orderBy('relation_table.title', 'ASC')
    ->with(['relationModal' => function ($q) {
        $q->where('column', 'value');
    }])->get();

+ Example:
$user = User::where('city', 'kullu')
    ->join('salaries', 'users.id', '=', 'salaries.user_id')
    ->orderBy('salaries.amount', 'ASC')
    ->with(['salaries' => function ($q) {
        $q->where('amount', '>', '500000');
    }])->get();


+ How to sort a Laravel query builder result by multiple columns?
    + https://stackoverflow.com/questions/17006309/how-to-sort-a-laravel-query-builder-result-by-multiple-columns
    Simply invoke orderBy() as many times as you need it. For instance:

    User::orderBy('name', 'DESC')
        ->orderBy('email', 'ASC')
        ->get();
    Produces the following query:

    SELECT * FROM `users` ORDER BY `name` DESC, `email` ASC




+ Trường hợp : Các bảng đã được tạo, sau đó ta cập nhật các cột mới 
    => muốn chỉ chạy lại bảng đó => (cao nhất thì chỉ là mất dữ liệu của bảng đó)
    => dữ liệu các bảng khác vẫn dược dữ nguyên như cũ . 
    
    => thực hiện : php artisan migrate:refresh --path=database/migrations/[ name_file.php ]
    ví dụ : php artisan migrate:refresh --path=database/migrations/2022_09_27_192258_create_import_details_table.php
    => nó sẽ thực hiện 2 lệnh : Rolled back và Migrated bảng đó cho ta . 

    (Nếu rảnh thì thử làm cách khác, thay vì gõ lệnh trên thì ta : dùng 2 lệnh Rolled back và Migrated cho bảng đó)
    ALTER TABLE import_details ADD FOREIGN KEY(product_id) REFERENCES products(id);
    ALTER TABLE import_details ADD FOREIGN KEY(import_id) REFERENCES imports(id);
    ALTER TABLE imports ADD FOREIGN KEY(provider_id) REFERENCES providers(id);

    
    
+ Thật ra mỗi lần thay đổi gì đó ta không cần request lại trang cũng được 
    => Ta sẽ gọi lại hàm lấy dữ liệu lại để nó load lại thôi
    => Nhưng nếu request lại trang đôi lúc nó sẽ làm sạch và reset mọi thứ trở về ban đầu, các biến được sử dụng 
    sẽ trở về ban đầu sẽ tốt hơn -> đỡ bug (nếu có)

+ Làm thêm cái hiện mật khẩu ở form đăng nhập 

+ Khi mà code trong vs code . Autocomplete nó bị mất , ví dụ code Vuejs mà bị mất thì xóa extension của Vuejs 
    sau đó cài lại là được . (Kiểm tra bằng cách nhấn ctrl + space (dấu cách) nếu nó không gợi ý code -> lỗi -> xóa cài lại)
    Hoặc mở lên mà nó không gợi ý code thì xóa cài lại . 
    => Dùng lâu nó mới bị lỗi nên không sao . Lỗi thì xóa cài lại thôi . 


+ Top Những hiệu ứng background trong html đẹp : 
    + https://blog.stackfindover.com/css-background-animation-examples/


+ Một product chưa có category thì trong database ta cho nó là null nhưng ở ngoài là chưa phân loại 



- QUAN TRỌNG : 
    + tham khảo : 
        + https://stackoverflow.com/questions/41621486/laravel-inner-join
        + https://stackoverflow.com/questions/23328301/laravel-eloquent-left-join-where-null
        + https://stackoverflow.com/questions/25509196/pagination-and-join-with-laravel
        + https://stackoverflow.com/questions/15158139/laravel-eloquent-as-keyword 

    + Tham khảo về JOIN , AS , SELECT + OrBy + function + orWhere + paginate trong eloquent laravel 
    + left join 2 bảng category và product lại nhưng cả 2 bảng đều có id,name -> trong laravel đè lên nhau -> chỉ hiện thị 1 cái
        -> dùng AS khi select 
    + tương tự khi tìm kiếm không biết đang tìm name của product hay name của category -> dùng product.name , categories.name 

    + "IN" trong eloquent laravel 
        + https://stackoverflow.com/questions/29115385/how-to-make-laravel-eloquent-in-query

    + Code : 
        $col1='products.id';
        $col2='products.name';
        $orderb1='ASC';
        $orderb2='ASC';

        $sortlatest = $request->sortlatest;
        $sortname = $request->sortname;
        
        if($sortlatest == 'true' && $sortname == 'true'){
            // Tên z-a 
            $col1='products.name';
            $col2='products.id';
            $orderb1='DESC';
        }
        else {
            // Mới nhất 
            if($sortlatest == 'true') $orderb1='DESC';

            // Tên a-z
            if($sortname == 'true'){
                $col1='products.name';
                $col2='products.id';
            }
        }

        $search = $request->search;
        $products = Product::leftJoin('categories', function($join) {
            $join->on('products.category_id', '=', 'categories.id');
          })->orderBy($col1,$orderb1)->orderBy($col2,$orderb2)->where(function($query) use($search) {
            $query->where('products.name','LIKE', '%'.$search.'%')
            ->orWhere('categories.name','LIKE', '%'.$search.'%')
            ->orWhere('quantity','LIKE', '%'.$search.'%')
            ->orWhere('warranty_period','LIKE', '%'.$search.'%')
            ->orWhere('description','LIKE', '%'.$search.'%')
            ->orWhere('price','LIKE', '%'.$search.'%')
            ->orWhere('material','LIKE', '%'.$search.'%')
            ->orWhere('dimension','LIKE', '%'.$search.'%');
        })->select(
            'products.*','products.id as product_id','products.name as product_name',
            'categories.*','categories.id as category_id','categories.name as category_name'
        )->paginate(10);

        // vì products và categories đều có các cột id và name nên ta dùng AS 

        $products2 = Product::leftJoin('categories', function($join) {
            $join->on('products.category_id', '=', 'categories.id');
          })->orderBy($col1,$orderb1)->orderBy($col2,$orderb2)->where(function($query) use($search) {
            $query->where('products.name','LIKE', '%'.$search.'%')
            ->orWhere('categories.name','LIKE', '%'.$search.'%')
            ->orWhere('quantity','LIKE', '%'.$search.'%')
            ->orWhere('warranty_period','LIKE', '%'.$search.'%')
            ->orWhere('description','LIKE', '%'.$search.'%')
            ->orWhere('price','LIKE', '%'.$search.'%')
            ->orWhere('material','LIKE', '%'.$search.'%')
            ->orWhere('dimension','LIKE', '%'.$search.'%');
        })->select(
            'products.*','products.id as product_id','products.name as product_name',
            'categories.*','categories.id as category_id','categories.name as category_name'
        )->get();


        // XỬ LÝ LẤY RA CÁC BỘ ẢNH TƯƠNG ỨNG 
        $idps = []; // mảng lưu các giá trị product_id 

        foreach ($products as $product) { // lượt qua các product của resource 
            // echo $product->product_id;
            array_push($idps,$product->product_id); // lấy ra các product_id của resource đó và thêm vào arr 
        }
        // print_r($arr);

        // CHÚ Ý : product_id là cột ta dùng AS để tự đặt tên ở phía trên (có hiệu lực trong resource) và bây giờ 
        // lấy ra dùng vẫn được  

        // $images = Image::whereIn('product_id',$arr)->get();

        $imgs = []; // mảng lưu các bộ ảnh 
        foreach($idps as $idp){ // lặp qua mảng id các sản phẩm 
            $image = Image::where('product_id',$idp)->get(); // ứng với mỗi id của product thì có bộ ảnh product đó 
            array_push($imgs,$image); // thêm bộ ảnh vào mảng ảnh 
        }
        // XỬ LÝ LẤY RA CÁC BỘ ẢNH TƯƠNG ỨNG 


        $n = count($products2); 
        return response()->json([
            'quantity' => $n,
            'message' => 'Get all providers successfully !',
            'product' => $products,
            // 'image' => $images,
            // 'arr' => $arr,
            'img' => $imgs,
        ], 201);

        => Lấy ra các product đó => Lấy ra mảng các mảng ảnh tương ứng 

    
+ Ta có thể dùng index khi v-for ra để tạo ra nhiều id khác nhau 
    <tbody v-for="(pr,index) in products" :key="index">  <!-- v-for ra các product -->
        <tr>
            <th scope="row">{{(pageN-1)*10+index+1}}</th>
            <td>{{pr.product_name}}</td>
            <td>
                <div :id="'carouselExampleControls'+index" class="carousel slide" data-ride="carousel">
                    <div class="carousel-inner">
                        <div class="carousel-item active imgproduct">  <!-- phải có cái active nêu fix bằng cách này , lấy cái ảnh đầu tiên  -->
                            <img class="d-block w-100" :src="domain+'/'+images[index][0].image_path" >
                        </div>
                        <!-- images[index] là mảng các ảnh tương ứng với product đó -->
                        <!-- từ images[index] lại tiếp tục v-for để hiển thị các ảnh trong mảng đó -->
                        <div class="carousel-item imgproduct" v-for="(img,index2) in images[index]" :key="index2">
                            <!-- index2 là index của for mảng các ảnh ở trong -->
                            <!-- index là index của for mảng các product -->
                            <img class="d-block w-100" :src="domain+'/'+img.image_path" >
                        </div>
                    </div>
                    <!-- Nhằm mục đích fix lỗi , chỉ click vào slider nào thì slider đó mới chuyển
                    các slider của hàng khác không liên quan nên mình fix bằng cách này -->
                                                    <!-- dùng index để bind thuộc tính href -->
                    <a class="carousel-control-prev" :href="'#carouselExampleControls'+index" role="button" data-slide="prev">
                        <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                        <span class="sr-only">Previous</span>
                    </a>
                                                    <!-- dùng index để bind thuộc tính href -->
                    <a class="carousel-control-next" :href="'#carouselExampleControls'+index" role="button" data-slide="next">
                        <span class="carousel-control-next-icon" aria-hidden="true"></span>
                        <span class="sr-only">Next</span>
                    </a>
                </div>

- Fix cho ảnh img nằm trong div tự canh chình (không bị cắt, không bị méo)
    <style>
        .imgproduct {
            width: 300px;
            height: 100px;
        }
        .imgproduct img {
            width: 100%; /* or any custom size */
            height: 100%; 
            object-fit: contain;
        } 
    </style>

- Trong migrate kiểu float nhưng đôi lúc vào database kiểu double 
    => vào đổi lại nếu không khi lưu dữ liệu có giá trị lớn sẽ gây lỗi 


- Đọc thêm : 
    + ALTER TABLE `import_details` CHANGE `provider_tax_id` `tax` VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL;
        => câu lệnh đổi tên cột 
    + Kinh Nghiệm : ta có thể dùng một bảng trong phpmyadmin để test từ đó học hỏi thêm các câu lệnh sql  

- ĐỔI TÊN CỘT thì đổi ngoài phpmyadmin xong rồi vào đổi trong file migrate  
- Viết chữ trong html : 
    + https://css-tricks.com/snippets/css/typewriter-effect/

- Animation Border Bottom 
    + https://www.niemvuilaptrinh.com/article/Nhung-Snippet-Cho-Animation-Border-202


- PDF 
    + Tham khảo một số cách sau đây 
        1. Dùng thư viện vue3-print-nb
            Nếu in mà không dùng framework ví dụ như bootstrap, chartjs ,... 
            + Mọi ảnh và màu sắc , kiểu chữ đều do ta tự style hết 
            => thì dùng : vue3-print-nb 
            + thamkhao : https://www.npmjs.com/package/vue3-print-nb 
            + thực hiện : 
                > npm install vue3-print-nb --save
                + main.js 
                    + import print from 'vue3-print-nb'
                    + app.use(print)

                + Component.vue 
                    + 
                    <div id="printMe">
                        Content ...
                    </div>
                    <button v-print="'#printMe'">Print local range</button>

                + ƯU ĐIỂM : 
                    + In tùy cái , thích cái nào in cái đó 
                    + Đơn giản sẽ sử dụng . 

        2. Dùng window.print() của js 
            + Không dùng thư viện gì cả , có sẵn trong js 
            + NHƯỢC ĐIỂM : In toàn bộ trang hiện hành 
            + KHẮC PHỤC : Để chỉ in cái mình muốn
                +  NHỮNG CÁI KHÔNG MUỐN IN THÌ ẨN ĐI 
                    <style scoped>
                        @media print {
                            body * :not(#printMe){
                            display:none;
                            }

                            body #printMe {
                            display:block;
                            }
                            html {
                            background-color: white;
                            }
                        }
                    </style>
                    => không được như thế này . 
                    cho toàn bộ body ẩn => no sẽ ẩn hết luôn , dù ta có cho #printMe hiện tại  
                    => Yêu cầu ta phải tổ chức lại cấu trúc html . để có thể ẩn các cái khác và giữ lại cái ta cần 

            + ƯU ĐIỂM : 
                + In được mọi thể loại frameword (nói chung là có trên trang hiện hành)
            + Nhược điểm : Đi tìm từng cái ta không cần để ẩn nó đi 
                + Nhiều cái có style này nó mình chỉnh lại không được thì in nó vẫn ra như thế luôn . 
                ex : để padding cho body 250px thì ẩn đi rồi nó vẫn còn nên in ra vẫn lỗi . 

        3. Dùng vue-html-to-paper 
            + ƯU điểm 
                + Không có lỗi gì cả
                + Đơn giản , dễ dùng , in được mọi thể loại 
            + NHƯỢC ĐIỂM : 
                + Chỉ dùng cho Vue2 
                
        4. Ngoài ra còn một số cái khác => không hiển thị ra mà tải file pdf trực tiếp xuống luôn . 


+ Vì giao diện User làm đầu nên cân nhắt làm một số cái sau 
    + Thanh navbar nằm ngang ở phía trên 
    + Backgroud giống như s group (có chuyển động và màu mè một chút)


    + Màu chủ đạo của các nút bấm các kiểu là màu cam (phân biệt so với màu xanh admin)
    + Chưa đăng nhập thì mọi dữ liệu điều được lưu vào localStorage 

    + Tổ chức và Xây dựng router trước sau đó 
    => Xây dựng giao diện chính trước , lưu dữ liệu ở localStorage trước 
    => Khi người dùng đăng nhập thì đổ dữ liệu ở localStorage vào database (và tất nhiên là xóa dữ liệu ở localStorage tạm đó đi)
    
    + Vue : WithScrollReveal in Vue , trong js tên là : ScrollReveal().reveal 
        + Được thì thêm cái hiệu ứng kéo scroll tới đâu thì hiện tới đó  
        + tham khảo : file:///E:/E/Users/M%C3%A1y%20t%C3%ADnh/Modest%20v.2/index.html#features
            => áp dụng cho các li trong Footer và những cái khác xem thử . 
        
        + thamkhao : 
            + https://codesandbox.io/s/z2wqk3vm1l?file=/index.js:147-163 (top,bottom)
            + https://codesandbox.io/s/s27xs

            + https://50diy.csb.app/ (left, right)
            => chỉnh hiện kiểu gì cũng được 
        
    + Trong js gọi là Smooth Scrolling 
        + Click vào một cái gì đó thì nó trượt chứ không đến ngay  
        + Thêm nút ^ ở phía bên phải để khi người dùng click vào đó thì nó trượt lên 
            + thamkhao : file:///E:/E/Users/M%C3%A1y%20t%C3%ADnh/Modest%20v.2/index.html#features
        
        + Tham khảo : 
            + https://codesandbox.io/s/smooth-scroll-demo-forked-wwoqk5

    + Thêm google map vào vuejs (ở cuối trang show sản phẩm cho customer)
    + Nhắn tin đến fanpage của facebook 
        + keyword : vue-fb-customer-chat
        + https://embedsocial.com/blog/facebook-messenger-chat-plugin/

    + Gọi : <p><a href="tel:+4733378901">+47 333 78 901</a></p>
        => dùng trực tiếp bằng html 
    + Email : <a href="mailto:webmaster@example.com"></a>
        => dùng trực tiếp html 
    
    + tham khảo : vue-social-chat (bao gồm : WhatsApp, Telegram, Messenger, WeChat, Line, Viber) (HAY)
        + https://www.vuescript.com/social-chat/ (HAY)
        + https://codesandbox.io/s/qmg58?file=/src/components/HelloWorld.vue
        + Whatsapp, Telegram, Messenger, WeChat, Twitter, Viber, Line chat, Email client, Custom Chat Form Or mixed

    + Ngoài nút nhắn tin còn thêm nút gọi bằng điện thoại nữa . 

    + Có Header và Cả Footer (trang dưới cùng)
        + Ở cuối cái Footer sẽ bao gồm 
            + Thông tin của doanh nghiệp meta shop , các thông tin liên hệ ,...

            + Đúng lý ra ta phải thêm cái gọi là big category 
            sẽ bao gồm nhiều category nhỏ nữa . 
            => như vậy phải có thêm một table big category nữa . 

            + tham khảo phần footer của trang lazada : 
            + Các category được chia lại . 
                + Ví dụ : Bàn phím , lót chuột , tai nghe , ... sẽ được chia lại vào trong phụ kiện . 
                    => category là : Bàn phím , lót chuột , tai nghe , ... 
                    => còn big category là : Phụ kiện 
                + Ta sẽ fix lại nếu được . 
                => Còn không thì liệt kê theo dạng như tag ví dụ : 
                    + tai nghe, lót chuột, bàn phím,.... không theo dạng ul li
                
            + Và dù là cách nào thì khi click vào category đó thì cũng chuyển đến trang show ra các sản phẩm 
            của category đó . 


    + Giao diện của người dùng là màu cam (như shopppe) (của admin là màu xanh dương)
    + Mỗi lần đơn hàng có thay đổi là mỗi lần gửi mail về người dùng 
    + Thay avartar 
        + như bên admin 
        + hoặc click vào avatart hiện tại (hoặc icon) thì nó gọi hàm import ảnh 
        + và cho hiển thị ảnh thay thế ngay avartar hiện tại luôn 
            + chỉ cần thay link hiện tại bằng giá trị link (nằm trong mảng được upload lên)
            => nói chung là tương tự như bên product 

    + Mỗi lần người dùng thêm vào giỏ hàng thì cho sự kiện xảy ra từ component con để thông báo đến 
    header để cập nhật lại số hàng trong giỏ (nằm trong component header) 
    (bởi vì icon giỏ hàng nằm trên head nên nếu nó không tự cập nhật lại được)
    (Nếu ta không dùng VueX thì dùng Event Bus cũng được)
 
    + Vì khi hiển thị ra ở product ta không cần đánh số thứ tự dựa vào index , chỉ cần thanh paginate để click chuyển trang thôi 
    + Nên ta sẽ cho nhiều kiểu hiện thị sản phẩm ra ví dụ lấy ra 20 sản phẩm . 
        + Ta sẽ cho 10 sản phẩm hiện thị kiểu này 
        + 6 sản phẩm hiển thị kiểu kia 
        + tương tự 4 sản phẩm còn lại 

        (Thêm hàng gồm : các sản phẩm mới ví dụ lấy ra 10 sản phẩm mới)
        => tạo độ phong phú cho giao diện trở nên tự nhiên và đẹp hơn 
        => Vẫn đảm bảo đủ mọi chứ năng cho người dùng đối với sản phẩm đó . 

        + Mình không fix cứng ảnh để làm các trang lớn slide (đầu tiên) 
            nhưng nếu lấy ra các ảnh của sản phẩm nằm trong kho thì một số ảnh lại lại không đẹp mà mỗi slide mỗi ảnh như thế thì xấu
            => Mình sẽ lấy ra nhiều ảnh , mỗi slide lớn của cái slider to nhất nằm đầu tiên là tập hợp của nhiều ảnh lại 
            => nhìn cũng khá đẹp . 

    + Khi mà tìm kiếm (lọc các kiểu hoặc sắp xếp các kiểu) 
        + Nếu như không đủ số lượng ví dụ lấy ra được có 12 sản phẩm => 10 + 6 + 4 
        => chỉ tới ngang 12 = 10 + 2 => đến ngang 10 và 6 thôi nên ta sẽ ẩn 4 đi 
        (ẩn đi luôn cho khỏe tránh đôi lúc ngoài những cái v-for ra ta còn bỏ text và hiển thị ảnh)
            => thì nó sẽ chỉ có những cái ta fix cứng và ảnh bị lỗi chứ không có gì cả . 

    + Khi làm đầy đủ rồi thì cân nhắt việc thêm vào phần đầu khi hiển thị ra product là các sản phẩm được 
    mua nhiều các kiểu ,...



    + Code Login, logout, forgot password 
    + BackEnd chỉ cho phép đăng nhập bằng Email , nếu code thêm đăng nhập bằng Số điện thoại nữa thì 
        + Ý tưởng là where email từ số điện thoại đó ra rồi đăng nhập với password 
    
    + Sửa domain : 
        + Đăng nhập Google thì sửa trong file : oauth2.blade.php
        + Gửi mail để quên mật khẩu thì sửa trong file : Mail/NotifyMail.php và Mail/NotifyMailCustomer.php 
        + Các file trong folder config (nếu có)

    + Footer màu xanh đậm hoặc màu xanh đen (như blog)
    + Đến http://localhost:8080/main/account thì sẽ cho nó chuyển đến ngay http://localhost:8080/main/account/profile
        => vì http://localhost:8080/main/account chỉ có file Account thôi không có nội dung gì cả 
        nên code vào đó và cho nó chuyển đến http://localhost:8080/main/account/profile ngay 

    + Scroll to page top button (khi đến một vị trí nhất định mà cách xa phía trên thì nó sẽ hiện ra
        các cái nút này, để mình click vào thì nó kéo lên cho nhanh)
        https://vuejsexamples.com/scroll-to-page-top-button-with-vue-js/
        https://vuejsexamples.com/a-back-to-top-component-for-vue-js-which-scroll-page-to-the-top-when-clicked/
        https://vuejsexamples.com/a-scroll-back-to-top-button-in-vue-js/

    + Button Share : (chia sẽ trang hiện tại cho một nền tảng mạng xã hội nào đó)
        + https://www.npmjs.com/package/vue-share-buttons
            => cái này tổng hợp rất là nhiều nền tảng 
        + https://codesandbox.io/s/vvyjzw491l?file=/src/App.vue
        + https://codesandbox.io/s/rrlli
        + https://developer.twitter.com/en/docs/twitter-for-websites/tweet-button/overview

    + Sửa lại show hide của các phần login , register nếu có . 

    + Phần Dashboard : 
        + Category được hiện thị ra bao gồm : 
            + All (tất cả) 
            + Các category cụ thể 
            + Other (khác) (tức sẽ lấy ra những cái chưa được phân loại)

        + Phần sản phẩm : 
            + Tên sản phẩm 
            + Các hình ảnh của sản phẩm nếu có (nếu không có thì phải làm tương tự như component product)
            + Giá sản phẩm 

        + Tìm kiếm sản phẩm :
            + Trong trường hợp nào thì thanh sắp xếp cũng để nguyên 
                + Sắp xếp theo mới nhất 
                + Sắp xếp theo giá (từ thấp đến cao, từ cao đến thấp)

            + Click vào category thì nó sẽ hiện ra giao diện gồm các sản phẩm thuộc category đó 
                
            + Khi tìm kiếm :
                + Sẽ hiện ra : bên trái là thanh lọc (giá từ đâu đến đâu)

        + Khi hover vào sản phẩm sẽ có thêm vào giỏ hàng hoặc là xem chi tiết 
            +            View Details  
            +            - [123] + Add to Cart (min 0)
                + Nếu không đủ thì báo đã hết hàng 
                + Nếu còn đủ số lượng thì báo thành công 
                    + Lúc này nó sẽ phát event cho header bắt và thêm sản phẩm này vào header 
                    + Lưu biến vào localstorage (nếu là account chưa đăng nhập)
                        + Khi đăng nhập vào nếu 



+ Particles.vue Examples (hiệu ứng có mấy que hoặc hình chạy ngẫu nhiên hoặc ta di chuột vào)
    + https://codesandbox.io/s/touf7
    + https://codesandbox.io/s/autumn-pine-zt6y6s?file=/src/App.vue
    + https://zt6y6s.csb.app/
    + https://southteam.vn/danh-muc/mau-giao-dien-website-ban-hang/
    + Vue3 : 
        + https://codepen.io/collection/DPOage
        + https://www.npmjs.com/package/particles.vue3
        + https://codesandbox.io/s/7hhv5 (Vừa có Particles  "particles.vue3": "1.16.1", vừa có chạy chữ)
        + Chạy chữ trong Vue có library là : "typeit": "7.0.4",
        => chú ý nên cài đúng version thì nó mới chạy 
            <!-- <template>
                <h1 id="typed-text"></h1>
            </template>
            
            <script>
            import TypeIt from "typeit";
            import { onMounted } from "vue";
            
            export default {
                name: "Text",
                setup() {
                onMounted(() => {
                    new TypeIt("#typed-text", {
                    speed: 100,
                    lifelike: true,
                    cursor: true,
                    cursorSpeed: 3000,
                    loop: true,
                    })
                    .type("👋 Hi ! I'm Wei Chun")
                    .pause(500)
                    .delete()
                    .type(" I'm a software developer 🚀 ")
                    .pause(500)
                    .go();
                });
                },
            };
            </script>
            
            <style>
            #typed-text {
                color: #000000;
            }
            </style> -->


+ QUAN TRỌNG : 
    + Fix lỗi slider của bootstrap , checkbox và có thể có một số thứ khác đè lên thanh header 
        => fix bằng cách thêm z-index : 1 vào cho header 
        + Ta được : 
            #header {
                width: 100%;
                position: -webkit-sticky;
                position: sticky;
                top: 0;
                background-color: white;
                z-index: 1;
            }

            => z-index: 1 mạnh tới mức ngay cả background (nhiều que chuyển động đó) cũng không ghi đè lên được  
        + link tham khảo : 
            + search : slider bootstrap override div
            + https://stackoverflow.com/questions/53996581/bootstrap-carousel-is-being-overridden-by-custom-css-and-shows-all-images
            + Bootstrap carousel is being overridden by custom css and shows all images
            + What No One Told You About Z-Index
            + https://philipwalton.com/articles/what-no-one-told-you-about-z-index/
            
            => tiếp tục khẳng định một điều là : hãy cố gắng rồi bug đó sẽ được fix . 
            => những cái mình gặp rồi thì người khác cũng gặp rồi => vấn đề là hãy tìm và mô tả cho đúng lỗi 
            thì kết quả sẽ được hiển thị từ đó làm theo và fix .  

    + Ngoài thanh heder cố định ta còn có thể làm : Thanh header ẩn hiện khi ta scroll 
        + key word : show hide header on scroll
        + tham khảo : 
            + https://www.w3schools.com/howto/howto_js_navbar_hide_scroll.asp
            + https://codesandbox.io/s/g5upmh
            + https://g5upmh.csb.app/
            + https://codepen.io/neutraltone/pen/poobdgv

        + code in html : 
                <!DOCTYPE html>
                <html>
                <head>
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <style>
                body {
                    margin: 0;
                    background-color: #f1f1f1;
                    font-family: Arial, Helvetica, sans-serif;
                }
                
                #navbar {
                    background-color: #333;
                    position: fixed;
                    top: 0;
                    width: 100%;
                    display: block;
                    transition: top 0.3s;
                }
                
                #navbar a {
                    float: left;
                    display: block;
                    color: #f2f2f2;
                    text-align: center;
                    padding: 15px;
                    text-decoration: none;
                    font-size: 17px;
                }
                
                #navbar a:hover {
                    background-color: #ddd;
                    color: black;
                }
                </style>
                </head>
                <body>
                
                <div id="navbar">
                <a href="#home">Home</a>
                <a href="#news">News</a>
                <a href="#contact">Contact</a>
                </div>
                
                <div style="padding:15px 15px 2500px;font-size:30px;margin-top:30px;">
                <p><b>This example demonstrates how to hide a navbar when the user starts to scroll the page.</b></p>
                <p>Scroll down this frame to see the effect!</p>
                <p>Scroll up to show the navbar.</p>
                <p>Lorem ipsum dolor dummy text sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
                <p>Lorem ipsum dolor dummy text sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
                </div>
                
                <script>
                    var prevScrollpos = window.pageYOffset;
                    window.onscroll = function() {
                    var currentScrollPos = window.pageYOffset;
                    if (prevScrollpos > currentScrollPos) {
                        document.getElementById("navbar").style.top = "0";
                    } else {
                        document.getElementById("navbar").style.top = "-50px";
                    }
                    prevScrollpos = currentScrollPos;
                    }
                </script>
                
                </body>
                </html>

    + Code in Vuejs : 
        + Trong Vuejs để bắt sự kiện window.onscroll dùng : 
            export default {
                created () {
                    window.addEventListener('scroll', this.handleScroll);
                },
                destroyed () {
                    window.removeEventListener('scroll', this.handleScroll);
                },
                methods: {
                    handleScroll (event) {
                        // Any code to be executed when the window is scrolled
                    }
                }
            }
               
            => trong Vue3 thay destroyed bằng unmounted

        
    + Vậy cuối cùng ta có (tất nhiên với cách này để thanh header không bị đè lên bởi bất cứ thứ gì thì ta vẫn thêm z-index:1 ) :
        <template>
            <div id="app">
            <body>
            
            <div id="navbar">
            <a href="#home">Home</a>
            <a href="#news">News</a>
            <a href="#contact">Contact</a>
            </div>
            
            <div style="padding:15px 15px 2500px;font-size:30px;margin-top:30px;">
            <div id="carouselExampleControls" class="carousel slide" >
            <div class="carousel-inner">
                <div class="carousel-item active">
                <img class="d-block w-100" src="https://scontent.fsgn2-5.fna.fbcdn.net/v/t39.30808-6/278279382_1402357783541803_7534395471781085005_n.jpg?_nc_cat=106&ccb=1-7&_nc_sid=e3f864&_nc_ohc=_id0P92wdGcAX-h-4eG&_nc_ht=scontent.fsgn2-5.fna&oh=00_AfDs8qIWiHDCJs75iRZCgDc9NorYU5SuXyswC0TqAS13rA&oe=6366B394" alt="First slide">
                </div>
                <div class="carousel-item">
                <img class="d-block w-100" src="https://scontent.fsgn2-5.fna.fbcdn.net/v/t39.30808-6/278279382_1402357783541803_7534395471781085005_n.jpg?_nc_cat=106&ccb=1-7&_nc_sid=e3f864&_nc_ohc=_id0P92wdGcAX-h-4eG&_nc_ht=scontent.fsgn2-5.fna&oh=00_AfDs8qIWiHDCJs75iRZCgDc9NorYU5SuXyswC0TqAS13rA&oe=6366B394" alt="Second slide">
                </div>
                <div class="carousel-item">
                <img class="d-block w-100" src="https://scontent.fsgn2-5.fna.fbcdn.net/v/t39.30808-6/278279382_1402357783541803_7534395471781085005_n.jpg?_nc_cat=106&ccb=1-7&_nc_sid=e3f864&_nc_ohc=_id0P92wdGcAX-h-4eG&_nc_ht=scontent.fsgn2-5.fna&oh=00_AfDs8qIWiHDCJs75iRZCgDc9NorYU5SuXyswC0TqAS13rA&oe=6366B394" alt="Third slide">
                </div>
            </div>
            <a class="carousel-control-prev" href="#carouselExampleControls" role="button" data-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="sr-only">Previous</span>
            </a>
            <a class="carousel-control-next" href="#carouselExampleControls" role="button" data-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="sr-only">Next</span>
            </a>
            </div>
            <p><b>This example demonstrates how to hide a navbar when the user starts to scroll the page.</b></p>
            <p>Scroll down this frame to see the effect!</p>
            <p>Scroll up to show the navbar.</p>
            <p>Lorem ipsum dolor dummy text sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            <p>Lorem ipsum dolor dummy text sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            </div>
            </body>
            
            </div>
            </template>
            
            <script>
            export default {
            name: "App",
            data() {
                return {
                    prevScrollpos : window.pageYOffset,
                };
            },
            created () {
                window.addEventListener('scroll', this.handleScroll);
            },
            unmounted () {
                window.removeEventListener('scroll', this.handleScroll);
            },
            methods: {
                handleScroll () {
                // Any code to be executed when the window is scrolled
                var currentScrollPos = window.pageYOffset;
                if (this.prevScrollpos > currentScrollPos) {
                    document.getElementById("navbar").style.top = "0";
                } else {
                    document.getElementById("navbar").style.top = "-300px";
                }
                this.prevScrollpos = currentScrollPos;
                }
            }
            
            };
            </script>
            <style scoped>
            body {
                margin: 0;
                background-color: #f1f1f1;
                font-family: Arial, Helvetica, sans-serif;
            }
            
            #navbar {
                background-color: #333;
                position: fixed;
                top: 0;
                width: 100%;
                display: block;
                transition: top 0.3s;
                z-index: 1;
            }
            
            #navbar a {
                float: left;
                display: block;
                color: #f2f2f2;
                text-align: center;
                padding: 15px;
                text-decoration: none;
                font-size: 17px;
            }
            
            #navbar a:hover {
                background-color: #ddd;
                color: black;
            }
            </style>


+ Trước khi deploy thì thử lấy project trên github về sau đó tạo database mới với cơ sở dữ liệu được tạo mới ngay từ đầu 
xem có gì lỗi không . Vì khi deploy lên thì chạy mới lại hoàn toàn . 


+ Trong file php có tồn tại echo thì trả về json sẽ lỗi font 

+ Trong file resful 
    _getHeaders(){ 
        let headers = {};  // Đây là khai báo một object 
        if(admin !== null){
            headers.Authorization = 'Bearer ' + admin.access_token; // Authorization là thuộc tính của nó 
        }
        return headers;
    },

    get(url){
        return new Promise( (resolve, reject) =>{ 
            axios.get(
                config.API_URL + '/' + url  , 
                {
                    headers : this._getHeaders()
                }
            )
            .then( response =>{
                resolve(response.data);

    + Chưa sét đến điều kiện các kiểu , thì ta có thể ghi lại là : 
    get(url){
        return new Promise( (resolve, reject) =>{ 
            axios.get(
                config.API_URL + '/' + url  , 
                {
                    headers : {
                        Authorization = 'Bearer ' + access_token
                    }
                }
            )
            .then( response =>{
                resolve(response.data);


+ Html cũng có kiểu type dành cho điện thoại và bắt lỗi theo yêu cầu của ta : 
    + thamkhao : https://www.w3schools.com/tags/tryit.asp?filename=tryhtml5_input_type_tel
        <!DOCTYPE html>
        <html>
        <body>

        <h1>Display a Telephone Input Field</h1>

        <form action="/action_page.php">
        <label for="phone">Enter a phone number:</label><br><br>
        <input type="tel" id="phone" name="phone" placeholder="123-45-678" pattern="[0-9]{3}-[0-9]{2}-[0-9]{3}" required><br><br>
        <small>Format: 123-45-678</small><br><br>
        <input type="submit">
        </form>

        </body>
        </html>

+ ctrl + alt + mũi tên => chọn được nhiều vị trí 
    + ctrl + shift + mũi tên qua phải => chọn được nhiều từ 
+ sau đó chọn đủ số vị trí tương tứng với số từ copy được => paste 

+ window + shift + s hoặc ctrl + alt + s => đều chụp màn hình 

+ z-index là một thuộc tính rất mạnh , nó có thể phân chia ra các lớp 
    Ví dụ z-index : 2 sẽ nằm trên z-index : 1 
    Ví dụ Thanh SideBar của user có một số style bị slide trong user đè lên 
    => để fix thì cho z-index : 1 , mặc khác ta cũng có head có z-index : 1 
    mà sidebar nằm sau nên ưu tiên hơn header => kết qủa là sidebar đè lên header 

    => fix bằng cách cho header : z-index : 2 , sidebar : z-index : 1
    Để cho Header luôn là cái to nhất , nằm trên hết 

    + Ta có thể dùng z-index đánh số từ 1 đến n để phân lớp => một thuộc tính rất mạnh  


+ Người dùng có 2 hình thức đăng nhập 
    + Nếu đăng nhập bằng tạo tài khoản 
        => Sẽ có địa chỉ 
        => Lấy địa chỉ đó bỏ vào địa chỉ nhận hàng luôn . 
        Sau này người dùng có thay đổi thì cập nhật lại địa chỉ nhận hàng mới sau .
    
        => Khi cập nhật mình sẽ yêu cầu nhập đủ các trường 
        => nên nếu đăng nhập bằng tài khoản thì chắc chắn có địa chỉ nhận hàng 
        
        + Người dùng nào có email fake thì chỉ là gửi mail thông báo cho người đó không được thôi (không có lỗi gì cả)
        + Hàng vẫn được vận chuyển đi . (Như bên quên mật khẩu vậy , ai dùng mail thật thì lấy lại password được)

    + Nếu đăng nhập bằng google 
        + Khi mà người dùng cập nhật thông tin tài khoản 
            => kiểm tra xem có địa chỉ nhận hàng chưa => nêu chưa có thì lấy thông tin đó cho vào luôn 

        + Nếu đến khi đặt hàng rồi mà người đùng vẫn chưa cập nhật thông tin mình 
        chưa có cả thông tin cá nhân và địa chỉ nhận hàng => thông báo cho người dùng cập nhật đã mới được 

        + Có thể không cần thông tin tài khoản nhưng thông tin về địa chỉ nhận hàng phải có 
            + Name 
            + Phone 
            + Adress
            + ... 

    + Tại một thời điển mỗi người chỉ có một địa chỉ ship hàng , còn vấn đề hàng này địa chỉ này hàng kia địa 
    chỉ kia , những địa chỉ cũ và mới , thay đổi thì đã được lưu vào customer_order
        + mỗi customer_order có địa chỉ các thứ ... vào gồm một hoặc nhiều nhiều order_detail 
        mỗi dòng order_tails ứng với mỗi sản phẩm được order tại địa trong customer_order 



+ 
    recipient_name, phone_number, address có thể null bởi vì người dùng có thểm thêm vào giỏ hàng trước 
    rồi sau đó khi người dùng bấm đặt hàng => ta kiểm tra chưa cập nhật thông tin mới báo để người dùng
    cập nhật, 
    còn chỉ cần người dùng bấm thêm vào giỏ hàng 

    hex_id được tạo tự động , customer_id được lấy từ người dùng 
    order_status => 0
    shipping_fee => giá sản phẩm nhân với số lượng sản phẩm đầu tiên được thêm vào giỏ hàng 

    nếu bỏ đi sản phẩm nào hoặc thêm bớt số lượng => cập nhật ở bảng order_detail 
    nếu thêm thì trừ quantity trong product đi , nếu bớt thì cộng lại cho quantity của sản phẩm đó 
    quantity < 0 thì báo hết < số hàng order thì báo không đủ hàng và báo số hàng tối đa còn lại   
    sau đó tiếp tục tính tổng toàn bộ trong order_detail rồi cập nhật lại shipping_fee
    cứ như thế 
    sau đó nếu admin hủy đơn thì thôi cho về lại toàn bộ product 
    còn xóa hay không thì sau này code rồi tính tiếp ,...



+ Biến laptop thành VPS 
    + thamkhao : 
        + https://vietnix.vn/bien-may-tinh-thanh-vps-server/
    + Đôi lúc sau này dùng máy này cài Ubuntu sau đó dùng máy này làm server 


+ Sau này muốn xem lại link gì thì cứ : ctrl + f 'https://'


+ Xử lí đổi mật khẩu cho người dùng đăng nhập bằng google 
    + vì họ có password là NULL nên không có mật khẩu cũ . 
    + Khi mới vào Component Change Password là gọi lên server => kiểm tra tài khoản đó có password hay không 
    nếu có trả về true , không trả về false => dùng cái này để ẩn hiện input password cũ luôn , 

    + Để cho đơn giản (mặt dù code dài dòng hơn chút nhưng khỏe) thì code thêm một hàm đổi mật khẩu trong CustomerAuth 
    + Khi bấm save thì với biến kiểm tra được lấy về ngay từ đầu (true hoặc false) thì tùy vào đó mà gọi hàm nào trên server . 
        Chỉ cần kiểm tra mật khẩu mới và cũ giống nhau và đúng quy tắc là được => là cập nhật lại mật khậu cho họ . 


+ Export một bảng hoặc cả database sau đó Import vào cũng vậy . Ta có thể import từng bảng riêng lẽ hoặc cả database . 

+ fix thêm lỗi , người dùng chọn đăng nhập bằng google => khi về lại trang login nhưng nếu có status = 0 thì không lưu user 
cho localStorage mà báo tài khoản đã bị khóa .  


+ Button Go Top in Vuejs : 
    + thamkhao : https://vuejsexamples.com/scroll-to-page-top-button-with-vue-js/
    

+ Một lưu ý cực kỳ quan trọng là không nên comment trong Postman
// Sẽ dần đến lỗi và không lấy được thuộc tính . 
/*
    {
        "category_name":"Điện thoại"  ////// Nếu chỉ dùng một dòng này thì chỉ để lại một dòng này 
        // "search":"vanmanh"
        // "price_from":0,
        // "price_to":30000,
        // "sortlatest":"true",
        // "sortprice":"true"

        => còn lại xóa đi , không được comment vì sẽ gây lỗi laravel sẽ không nhận giá trị $request được
    }
 */

 nếu chưa có thì push product vào mảng 
nếu có rồi thì cộng buy_number vào 
=> thực tế thì ta không cần check có vượt qúa số lượng hiện có của sản phẩm hay không vì 
client khác cũng đang thêm vào . nên chỉ check khi mà bấm mua hàng 

+ có một cách khác đó là khi thêm vào giỏ hàng là => quy xuất trên database và trừ luôn \
+ mua thì không nói rồi 
+ còn nếu xóa thì cộng vào database 
=> cách này cx đc 



+ $('.carousel').carousel({
    interval: false,
  });

=> bỏ auto chuyển slide bootstrap4 





+ Để fix lỗi vào http://localhost:8080/main không có gì hết thì thêm 
    this.$router.push({name:'DashboardUser'}); vào User.vue 
    => nhưng lại sinh ra lỗi khi vào một component bất kì thì lại trỏ về Dashoard lại 

    nên ta sẽ làm thế này : 
    if(to.path == '/main' || to.path == '/main/'){
        next({name:'DashboardUser'});
    }



+ Tiếp tục với lỗi lưu số vào laravel 
    + Mới sửa cột shipping_fee của CustomerOrder thành float độ dài 10
    + Sửa cột price của OrderDetail thành float 10  



+ Order 
    => Buy Now => cho mặc định status là 1  
    => chuyển vào bảng chờ xác nhận (WaitForConfirmation)

+ User 
    + WaitForConfirmation         
        + status : 1 => hủy đơn thì status = 0 => đơn này chuyển sang bảng CancelledComp
        + chỉ có thời gian order , tại đây có thể hủy đơn được 
        + admin xác nhận là chuyển sang bảng ship , xác nhận thì có thời gian xác nhận 
    + WaitingForShipping            
        + có thời gian order , xác nhận 
        + chưa có thời gian xác nhận đang vận chuyển         
        + status : 1 
    + DeliveringComp        
        + có thời gian order, xác nhận , đang vận chuyển 
        + chưa có thời gian đã vận chuyển 
        + status : 1 
    + DeliveredComp
        + có tất cả các loại thời gian           
        + status : 1 
    + CancelledComp
        + status : 0 => các đơn có status = 0 

+ Admin 
    + Tương tự 
    + WaitForConfirmation         
        + status : 1 => không xác nhận đơn thì status = 0 
        + Nút xem chi tiết 
        + Nút Xác nhận 
    + WaitingForShipping            
        + status : 1 
        + Nút xem chi tiết 
        + Nút xác nhận đang giao hàng 
    + DeliveringComp        
        + status : 1 
        + Nút xem chi tiết
        + Nút xác nhận đã giao hàng  
    + DeliveredComp
        + status : 1 
        + Nút xem chi tiết
        + Nút In phiếu (pdf)


+ Đang chờ giao hàng sẽ là : 
    + Không có thời gian xác nhận đang chờ giao hàng (whereNull)
    + Và đã có thời gian xác nhận đơn hàng (nếu không có sẽ lấy ra cả những đơn đang chờ xác nhận , vì những đơn này 
    cũng chưa có thời gian đang chờ xác nhận giao hàng) 


+ Thay "chart.js": "^2.9.4" bằng chart.js@4.1.1 vì nó có nhiều chức năng và document hơn 
    thay import {Chart} from 'chart.js'
    bằng import Chart from 'chart.js/auto';
    => còn lại đọc document rồi làm theo 
    => khi cài xong libray nào thì nên tắt chạy lại để server build lại => sẽ không lỗi (đọc thiếu library,package đã cài)
    
+ Note : 
    <canvas id="myChart2"></canvas>
    const ctx = document.getElementById('myChart2');
    => khi dùng nhiều chart trên cùng một component tuyệt đối phải đặt khác tên 
    (hoặc mỗi chart trong một component riêng biệt rồi cho component cha dùng thì cũng phải đặt khác tên, nếu không sẽ lỗi)


+ Thống kê theo tháng , quý , năm 
    + mỗi cái đều có data đi kèm label 
    + tháng này (ngày 1 đến ngày hiện tại của tháng này)
    + quý này thì kiểm tra tháng rơi vào quý nào , ta có 4 quý 
        1-2-3     4-5-6     7-8-9     10-11-12
    + theo năm thì lấy ra 12 tháng của năm này 
    
    + độ thị donut thì tổng số đơn , số đơn chờ xác nhận, chờ giao, đang giao, đã giao, đã hủy 

    + bảng sản phẩm : 
        + hiện tất cả các sản phẩm 
        + search (kèm paginate)
        + mã sản phẩm , tên sản phẩm số lượng bán ra (kèm link trỏ đến sản phẩm) , số lượng nhập vào , doanh thu  


+ https://datatables.net/examples/styling/bootstrap4 // bảng tự động có các nút sắp xếp và có search luôn 
    => làm bằng html,css,jquery 
    $(document).ready(function() {
        $("#example").DataTable(); // chỉ cần gọi DataTable() 
    });
    
    keysearch : DataTable

+ https://datatables.net/extensions/buttons/examples/styling/bootstrap4.html
    => có thêm cả in file pdf , excel từ bảng , copy từ bảng 
    (mà code khá là ít, chỉ vài dòng) 

+ import $ from 'jquery' (dùng trong một component của vuejs)


+ CMD : Thu nhỏ cửa sổ => lăn chuột để thu nhỏ cỡ chữ => mở rộng cửa sổ => sẽ hiển thị đầy đủ 

+ Một số kinh nghiệm khi deploy project cả vuejs và laravel 
    + Trong project vuejs một số thư mục khi đẩy lên github thì github sẽ loại ra như 
        dis, node_modules,... vì các thư mục này có thể được tạo bằng code có sẵn với các lệnh 
        npm run build, npm i ,... nên không đẩy lên để khỏi nặng bộ nhớ (của github) cũng như tăng tốc độ làm việc của dev 
    + Trong laravel thì có folder vendor  
    + Chính vì thế không được bỏ bất kì file video , hình ảnh , code ,... nào vào các folder bị github loại ra này 
        vì tất nhiên nó sẽ không được đẩy lên . 
    + Khi deploy bằng cách thông qua github thì sẽ gây lỗi
    + Mặt khác trong project vuejs khi ta npm run build => các tài liệu trong folder dist trong một thời gian ngắn  
    sẽ biến mất dẫn đến build lỗi chính vì thế ta lại càng không được để tài liệu nào trong đó . 
    => Nói chung các folder dist, node_modules, các folder được build ra ,... thì không đụng vào làm gì,
        mọi code vs file của ta thì bỏ vào folder src hoặc có thể bỏ ra ngoài folder lớn không liên quan đến build 

    + Tiếp đến là Tùy vào mình deploy lên đâu mà cấu hình 
        + ví dụ như deploy lên heroku thì trong project vuejs gốc phải tạo thêm file server.js các kiểu rồi code vào đó 
            phải chính lại một số thứ mới deploy được 

    + Một số khác thì chỉ cần tại máy project đó chạy bình thường , thực hiện các lệnh npm i thành công 
        thì thông qua github có thể deploy thành công mà không cần thêm file nào cả không cần cấu hình phức tạp 
        như : Vercel , Netlify ,.. các trang nầy cho phép deploy các project Front end (Vuejs, Reat, Angular,...) một 
        cách nhanh chóng và dễ dàng thông qua source trên github .
        
    + Ưu điểm của Vercel so với heroku là 
        + Không cần cấu hình phức tạp , không cần tạo thêm file 
        + Thao tác đơn giản 
        + Source code có thể deploy ở trạng thái private , nếu như bên heroku thì phải để source code ở chế độ public mới 
            deploy được thì bên này ở private ta vẫn có thểd deploy được . 